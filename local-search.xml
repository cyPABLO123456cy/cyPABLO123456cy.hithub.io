<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>96. 不同的二叉搜索树</title>
    <link href="/2023/06/01/96-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <url>/2023/06/01/96-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h2 id="链接">[链接🚀]</h2><h3 id="题目">题目</h3><figure><img src="../img/md/leetcode/96.png" alt="96" /><figcaption aria-hidden="true">96</figcaption></figure><h3 id="题解">题解</h3><p>这里主要解释一下递推公式，dp[i-j] 主要是正反遍历的每一个元素，而dp[j- 1]表达的是因为个数是从0开始的。 ### 代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.leetcode.cy.week;<br><br><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DBinarySearchTrees</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">/*× 需求分析：</span><br><span class="hljs-comment">        * 寻找不同的二叉搜索数</span><br><span class="hljs-comment">        * */</span><br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">cin</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        System.out.println(DBinarySearchTreesAC(cin.nextInt()));<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">DBinarySearchTreesAC</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= i; j++) &#123;<br>                dp[i] += dp[j - <span class="hljs-number">1</span>]*dp[i - j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>343.整数拆分</title>
    <link href="/2023/04/12/343-%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86/"/>
    <url>/2023/04/12/343-%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h2 id="链接">[链接🚀]</h2><h3 id="题目">题目</h3><figure><img src="../img/md/leetcode/343.png" alt="343" /><figcaption aria-hidden="true">343</figcaption></figure><h3 id="题解">题解</h3><p>要使一个数拆分后能得到的值相乘为最大值，意味着，若拆分后的数是近似值，那么拆分后的数相乘就越大。类似于9*9乘法表，枚举出两个数相乘得到所有可能的值</p><ol type="1"><li>j*(i-j):枚举一个整数为j（从0开始），另一个整数为（i-j）:因为i代表的是输入的整数</li><li>j*dp[i-j]：同样地，这也是枚举，dp[i-j]位置上的值与j相比较。 ###代码</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">integerBreak</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-comment">//define dp[i] : 输出n的最大值</span><br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-comment">//define dpAraay</span><br>        <span class="hljs-comment">//init dp</span><br>        dp[<span class="hljs-number">2</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= i/<span class="hljs-number">2</span>; j++) &#123;<br>                dp[i] = Math.max(dp[i], Math.max(j*(i-j), j*dp[i-j]));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>4.8号美团笔试真题及解析</title>
    <link href="/2023/04/08/4-8%E5%8F%B7%E7%BE%8E%E5%9B%A2%E7%AC%94%E8%AF%95%E7%9C%9F%E9%A2%98%E5%8F%8A%E8%A7%A3%E6%9E%90/"/>
    <url>/2023/04/08/4-8%E5%8F%B7%E7%BE%8E%E5%9B%A2%E7%AC%94%E8%AF%95%E7%9C%9F%E9%A2%98%E5%8F%8A%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="回文串">回文串</h1><p>题目描述：</p><p>给定一个字符串，问是否能够通过添加一个字母将其变成“回文串”。“回文串”是指正着和反着读都一样的字符串。如：”aa”,”bob”,”testset”是回文串，”alice”,”time”都不是回文串。</p><p>输入</p><p>一行一个有小写字母构成的字符串，字符串长度不超过10。</p><p>输出</p><p>如果输入字符串可以通过添加一个字符，则输出”YES”，否则输出”NO”。</p><p>题目限制</p><p><strong>时间限制：</strong>C/C++语言 1000 MS；其他语言<strong>3000</strong> MS<br /><strong>内存限制：</strong>C/C++语言 <strong>65536</strong>KB；其他语言<strong>589824</strong>KB</p><p>样例输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">coco<br></code></pre></td></tr></table></figure><p>样例输出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">Yes<br></code></pre></td></tr></table></figure><p>题解：</p><ol type="1"><li><p>先构造一个存放26个英文小写字母的字符数据</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">char</span>[] chars = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[<span class="hljs-number">26</span>];<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; chars.length; i++) &#123;<br>    chars[i] = (<span class="hljs-type">char</span>) (<span class="hljs-string">&#x27;a&#x27;</span>+i);<br>&#125;<br></code></pre></td></tr></table></figure></p></li><li><p>遍历该数组，依次将数组中的每个元素拼接到待判断的数组后面</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; chars.length; i++) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">sstr</span> <span class="hljs-operator">=</span> str + chars[i];<br>            <span class="hljs-keyword">if</span> (isPillon(sstr)) &#123;<br>                System.out.println(<span class="hljs-string">&quot;Yes&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == chars.length -<span class="hljs-number">1</span>)&#123;<br>                System.out.println(<span class="hljs-string">&quot;N0&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br></code></pre></td></tr></table></figure></p></li><li><p>另写一个函数判断字符串是否为回文串，回文串的含义：正着读和反着读都是一样的，因此，我字符串从后往前输出，若一样，则返回True。</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPillon</span><span class="hljs-params">(String str)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> str.length()-<span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            tmp += str.charAt(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> tmp.equals(str) ;<br>    &#125;<br></code></pre></td></tr></table></figure></p></li></ol><p>完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span> &#123;<br>    <span class="hljs-comment">/**题目描述：</span><br><span class="hljs-comment">     给定一个字符串，问是否能够通过添加一个字母将其变成“回文串”。 “回文串”是指正着和反着读都一样的字符串。如：”aa”,”bob”,”testset”是回文串，”alice”,”time”都不是回文串。</span><br><span class="hljs-comment">     输入描述</span><br><span class="hljs-comment">     一行一个有小写字母构成的字符串，字符串长度不超过10。</span><br><span class="hljs-comment">     输出描述</span><br><span class="hljs-comment">     如果输入字符串可以通过添加一个字符，则输出”YES”，否则输出”NO”。</span><br><span class="hljs-comment">     样例输入</span><br><span class="hljs-comment">     coco</span><br><span class="hljs-comment">     样例输出</span><br><span class="hljs-comment">     Yes</span><br><span class="hljs-comment">     规则</span><br><span class="hljs-comment">     请尽量在全场考试结束10分钟前调试程序，否则由于密集排队提交，可能查询不到编译结果</span><br><span class="hljs-comment">     点击“调试”亦可保存代码</span><br><span class="hljs-comment">     编程题可以使用本地编译器，此页面不记录跳出次数</span><br><span class="hljs-comment">     * */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">cin</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> cin.nextLine();<br><br>        <span class="hljs-type">char</span>[] chars = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; chars.length; i++) &#123;<br>            chars[i] = (<span class="hljs-type">char</span>) (<span class="hljs-string">&#x27;a&#x27;</span>+i);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; chars.length; i++) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">sstr</span> <span class="hljs-operator">=</span> str + chars[i];<br>            <span class="hljs-keyword">if</span> (isPillon(sstr)) &#123;<br>                System.out.println(<span class="hljs-string">&quot;Yes&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == chars.length -<span class="hljs-number">1</span>)&#123;<br>                System.out.println(<span class="hljs-string">&quot;N0&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPillon</span><span class="hljs-params">(String str)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> str.length()-<span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            tmp += str.charAt(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> tmp.equals(str) ;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="最大字符串">最大字符串</h1><p>题目描述</p><p>Jack正在查询他昨天打的AtForces在线比赛的rank，他发现当两位选手排名相同的时候，id字典序小的会排在前面，他有个想法，往id里插入一个字母c，能使得他的id能够尽量往前排。</p><p>输入</p><p>第一行一个字符串id，表示他的用户名（1≤id长度≤1000），保证只由小写字母组成。</p><p>第二行一个字符c，表示被添加进去的字符，保证为一个小写字母。</p><p>输出</p><p>共一行，修改后的字典序最小的字符串。</p><p>题目限制</p><p><strong>时间限制：</strong>C/C++语言 1000 MS；其他语言<strong>3000</strong> MS<br /><strong>内存限制：</strong>C/C++语言 <strong>65536</strong>KB；其他语言<strong>589824</strong>KB</p><p>样例输入</p><p>jackisnumberone</p><p>k</p><p>样例输出</p><p>jackiksnumberone</p><p>题解：</p><p>本题中需要得到一个字典序最小，既就是遍历字符串，将每个位置上的字符值与字符相比较，若当前i位置的字符的int值大于键入的字母，则将该字母插入到i位置。代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">T3</span> &#123;<br>    <span class="hljs-comment">/**题目描述</span><br><span class="hljs-comment">     Jack正在查询他昨天打的AtForces在线比赛的rank，</span><br><span class="hljs-comment">     他发现当两位选手排名相同的时候，id字典序小的会排在前面，</span><br><span class="hljs-comment">     他有个想法，往id里插入一个字母c，能使得他的id能够尽量往前排。</span><br><span class="hljs-comment">     输入</span><br><span class="hljs-comment">     第一行一个字符串id，表示他的用户名（1≤id长度≤1000），保证只由小写字母组成。</span><br><span class="hljs-comment">     第二行一个字符c，表示被添加进去的字符，保证为一个小写字母。</span><br><span class="hljs-comment">     输出</span><br><span class="hljs-comment">     共一行，修改后的字典序最小的字符串。</span><br><span class="hljs-comment">     题目限制</span><br><span class="hljs-comment">     时间限制：C/C++语言 1000 MS；其他语言 3000 MS</span><br><span class="hljs-comment">     内存限制：C/C++语言 65536KB；其他语言 589824KB</span><br><span class="hljs-comment">     样例输入</span><br><span class="hljs-comment">     jackisnumberone k</span><br><span class="hljs-comment">     样例输出</span><br><span class="hljs-comment">     jackiksnumberone</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">cin</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> cin.nextLine();<br>        <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> cin.nextLine().charAt(<span class="hljs-number">0</span>);<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; str.length(); i++) &#123;<br>            <span class="hljs-keyword">if</span> ((<span class="hljs-type">int</span>) str.charAt(i) &gt; (<span class="hljs-type">int</span>) c)&#123;<br><span class="hljs-comment">//substring()截取的是0到i-1的字符串</span><br>                tmp = str.substring(<span class="hljs-number">0</span>,i) + c + str.substring(i,str.length());<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (tmp == <span class="hljs-literal">null</span>)&#123;<br>                tmp = str.concat(c+<span class="hljs-string">&quot;&quot;</span>);<br>            &#125;<br>        &#125;<br>        System.out.println(tmp);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里对substring()做一个说明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">substring(startIndex , endIndex) <span class="hljs-comment">//截取包括startIndex , 但是不包括endIndex;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>2024暑期实习笔试</category>
      
      <category>赛码网练习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>4.1号美团笔试真题及解析</title>
    <link href="/2023/04/07/4-1%E5%8F%B7%E7%BE%8E%E5%9B%A2%E7%AC%94%E8%AF%95%E7%9C%9F%E9%A2%98%E5%8F%8A%E8%A7%A3%E6%9E%90/"/>
    <url>/2023/04/07/4-1%E5%8F%B7%E7%BE%8E%E5%9B%A2%E7%AC%94%E8%AF%95%E7%9C%9F%E9%A2%98%E5%8F%8A%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<figure><img src="../img/bg/meituan1.jpg" alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><h1 id="美团">美团</h1><h3 id="t1">T1</h3><p>题目描述：</p><p>第一行一个整数n，合义见题面。接下来一行n个整数a1,a2,..,an，依次表示小美初始写下的连加算式中的每一个数。接下来一个整数m，表示小美做了m次算数训练 接下来2m个以空格分开数字或符号t1,o1, t2,o2, ...tm,om，其中ti为数字，oi是'+','-','<em>','/'(即加减乘除符号，不含引号)中的一个符号，表示第i 次操作选定了第ti个加号，将其改变为了oi。对于所有的的数据,2≤N≤50000，1≤M≤50000,1≤ai≤500,1≤ti } ​</em></p><p>题目描述输出：<em>​ ​</em></p><p><em>输出一行m个整数，分别表示每次操作的答案，结果四舍五入到一位小数。样例输入： 5 1 2 4 2 5 3 1 - 2 </em> 4 / 样例输出： 10.0 16.0 7.4promot: 样例解释 第一次操作后算数式为1-2+4+2+5 = 10.0第二次操作后算数式为1+2*4+2+5 = 16.0 第三次操作后算数式为1+2+4+2/5 = 7.4值得注意的是，每次操作都认为对初始的全加号式子(此处为1+2+4+2+5)进行操作，操作之间互不影响。</p><p>题解：</p><ol type="1"><li>第一个数确定了下一行的个数</li><li>第三个数确定了最后一行的字符串长度为第三个数的2倍</li><li>第二个数组与第四个数组之间的关系：第四个数组上的整数值是第二个数组的索引</li><li>因此，我们先将第二个数组的总和先计算出来，然后再将变动数组的值单独计算</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span> &#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 接受用户输入</span><br><span class="hljs-comment">         * */</span><br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">cin</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">lineNum</span> <span class="hljs-operator">=</span> cin.nextInt();<br>        <span class="hljs-type">int</span>[] inputNum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[lineNum];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; lineNum; j++) &#123;<br>            inputNum[j] = cin.nextInt();<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">operateTimes</span> <span class="hljs-operator">=</span> cin.nextInt();<br>        String[] inputSequence = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[<span class="hljs-number">2</span>*operateTimes];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; len &lt; inputSequence.length; len++) &#123;<br>            inputSequence[len] = cin.next();<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 处理逻辑</span><br><span class="hljs-comment">         * */</span><br>        Double[] result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Double</span>[operateTimes];<br>        Double sum=<span class="hljs-number">0.0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; inputNum.length; i++) &#123;<br>            sum += <span class="hljs-number">1.0</span>*inputNum[i];<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 记录结果次数</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span> * operateTimes; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">operator</span> <span class="hljs-operator">=</span> inputSequence[i];<br>                <span class="hljs-type">String</span> <span class="hljs-variable">times</span> <span class="hljs-operator">=</span> inputSequence[i-<span class="hljs-number">1</span>];<br>                <span class="hljs-type">int</span> <span class="hljs-variable">time</span> <span class="hljs-operator">=</span> Integer.parseInt(times);<br><br>                <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> inputNum[time-<span class="hljs-number">1</span>] , b = inputNum[time];<br><br>                <span class="hljs-type">Double</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> sum - (a+b);<br>                <span class="hljs-keyword">switch</span> (operator)&#123;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;-&quot;</span>:<br>                        pre += (a-b);<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;/&quot;</span>:<br>                        pre += (a/b);<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;*&quot;</span>:<br>                        pre += (a*b);<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">default</span>:<br>                        pre += (a+b);<br>                        <span class="hljs-keyword">break</span>;<br>                &#125;<br>                result[k] = pre;<br>                k++;<br>            &#125;<br>        &#125;<br><br>System.out.println(Arrays.toString(result).replace(<span class="hljs-string">&quot;[&quot;</span>,<span class="hljs-string">&quot;&quot;</span>)<br>                .replace(<span class="hljs-string">&quot;,&quot;</span>, <span class="hljs-string">&quot; &quot;</span>)<br>                .replace(<span class="hljs-string">&quot;]&quot;</span>, <span class="hljs-string">&quot;&quot;</span>));<br></code></pre></td></tr></table></figure><h3 id="t2">T2</h3><p>题目描述：</p><p>小美正在整理桌子上的一排装饰品。小美对待装饰品摆放方式的审美角度很奇特，她认为高度相差比较大的装饰品放在相邻位置会很难看，她想对这一排装饰品进行整理，可以交换任意两个装饰品的位置任意多次。假设当前从左到右n个装饰品的高度分别为h1,h2,...,hn，那么当前这一排装饰品的丑陋值为，其中|x|为x的绝对值。小美想最小化她的装饰品的丑陋值，请你帮她排一下顺序。形式化地来讲，有一长为n的序列a1,a2,...,an，你可以任意次数地进行交换，每次交换都可以选择任意两个不同的数i,j,交换ai,aj的位置。假设经过若干次交换后，序列变为h1,h2,...,hn，其丑陋值为，你需要找出一种交换方式，使得最终序列{hn}的丑陋值最小化。你不需要输出具体交换方式，只需要输出最终的{hn}序列的丑陋值即可。输入描述 第一行一个整数n，表示小美的装饰品数量。接下来一行n个整数a1,a2,...,an，依次表示从左到右n个装饰品的高度。对于所有的数据:2≤N≤50000，0≤ai≤109。 输出描述输出第一行一个数，为最优方案的最小丑陋值。</p><p>样例输入：</p><p>3</p><p>3 1 2</p><p>样例输出</p><p>2</p><p>提示</p><p>我们可以将3和1交换，得到 1 3 2 然后再将2和3交换，得到 1 2 3可以证明，此时有最小丑陋值</p><p>|1-2|+|2-3|=2</p><p>题解：</p><ol type="1"><li>分析输入。输入的第一个值确定了一共有多少个数可以输出，输出的值要求最少，相邻元素之间的差最小，因此将输入序列排序，然后依次计算两两数的差。详细代码如下：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">cin</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> cin.nextInt();<br><br>        <span class="hljs-type">int</span>[] InputNum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; InputNum.length; i++) &#123;<br>            InputNum[i] = cin.nextInt();<br>        &#125;<br><br>        Arrays.sort(InputNum); <span class="hljs-comment">// sort</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) &#123;<br>            <span class="hljs-comment">//为什么是n - 1？</span><br>            <span class="hljs-comment">//需要使用i , i+1 , 因此当i = n - 2时，i + 1 = n - 1，刚好等于最后一个数组的值；</span><br>            res += Math.abs(InputNum[i] - InputNum[i+<span class="hljs-number">1</span>]);<span class="hljs-comment">//取绝对值的差</span><br>        &#125;<br>        System.out.println(res);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="t3">T3</h3><p>题目描述：</p><p>小美爱上了收藏！现在她给自己修建了一排n个收藏夹分别编号为1,2,3,...,n。有时小美会改变某一个收藏夹里的内容，例如从中拿入、拿出一些藏品，这样的操作会改变小美对这个收藏夹的欣赏程度，我们记编号为i的收藏夹小美对其的欣赏程度为ai。还有一些时候，小美会欣赏连续编号的一些收藏夹，例如编号为L,L+1,L+2,...,R-1,R的这一些收藏夹，她能从中获得的满足感为这些收藏夹的欣赏程度之和，即。小美想在欣赏之前提前做一些评估，想知道如果她选择编号区间为[L,R]的收藏夹，能给她带来的满足感是多少。小美想请你，最好的朋友，来帮帮她。</p><p>输入描述：</p><p>第一行两个整数n和m，表示小美的收藏夹数量和小美的操作数量。初始时刻收藏夹都是空的，也即ai=0(i∈[1,n])第二行m个整数op1,op2,...,opm。 第三行m个整数x1,x2,...,xm。第四行m个整数y1,y2,...,ym，这些共同表示了m次操作。</p><p>具体而言，对第i次操作，opi=0时表示为一次收藏夹更新操作，会将xi位置的收藏夹欣赏程度更新为yi，即axi=yi；opi=1时表示为一次查询操作，表示如果小美欣赏编号在区间[xi,yi]的收藏夹，能获得的满足感是多少，也即的值。对于所有的数据，1≤n,m≤ 50000,opi∈{0,1},当opi=0 时,1≤xi≤n,0≤yi≤10000;当opi=1 时，1≤xi≤yi≤n。保证至少有一次opi=1 的操作。</p><p>输出描述：</p><p>对每个opi=1的操作，输出一个数表示对应答案。空格隔开所有答案。</p><p>样例输入：</p><p>4 7</p><p>1 0 1 0 1 0 1</p><p>1 1 1 3 1 4 1</p><p>3 2 3 5 3 100 3</p><p>样例输出</p><p>0 2 7 7</p><p>提示</p><p>样例解释 操作记录为 0 0 0 0 (初始) &lt;询问[1,3],结果为0+0+0&gt; 2 00 0 &lt;1号更改为2&gt; &lt;询问[1,3],结果为2+0+0&gt; 2 0 5 0&lt;3号更改为5&gt; &lt;询问[1,3],结果为2+0+5&gt; 2 0 5 100&lt;4号更改为100&gt; &lt;询问[1,3],结果为2+0+5&gt;</p><p>题解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">cin</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> cin.nextInt();<span class="hljs-comment">//收藏n个物品</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> cin.nextInt();<span class="hljs-comment">//m次操作</span><br>        cin.nextLine();<br><br>        <span class="hljs-type">int</span>[] collects = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-type">int</span>[] operator = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m];<span class="hljs-comment">//存储操作数组</span><br>        <span class="hljs-type">int</span>[] operatorArray1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m]; <span class="hljs-comment">//one</span><br>        <span class="hljs-type">int</span>[] operatorArray2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m]; <span class="hljs-comment">//two</span><br><br><span class="hljs-comment">//        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="hljs-comment">//            collects[i] = 0;</span><br><span class="hljs-comment">//        &#125;</span><br><br><span class="hljs-comment">//        cin.nextLine();</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; operator.length; i++) &#123;<br>            operator[i] = cin.nextInt();<br>        &#125;<br><br>        cin.nextLine();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; operatorArray1.length; i++) &#123;<br>            operatorArray1[i] = cin.nextInt();<br>        &#125;<br><br>        cin.nextLine();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; operatorArray2.length; i++) &#123;<br>            operatorArray2[i] = cin.nextInt();<br>        &#125;<br><br>        <span class="hljs-comment">// deal logic</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; operator.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (operator[i] == <span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> operatorArray1[i] -<span class="hljs-number">1</span>; j &lt; operatorArray2[i]; j++) &#123;<br>                    res += collects[j];<br>                &#125;<br>                System.out.println(res);<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                collects[operatorArray1[i]-<span class="hljs-number">1</span>] = operatorArray2[i];<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="t4">T4</h3><p>题目描述：</p><p>小美最近在魔法课中掌握了倒水魔法：可以运用法力隔空倒水。最近魔法课考试临近，小美早早地来到了魔法训练室训练难以掌握的倒水魔法。魔法训练室里有n个神奇的杯子，有着不同的大小，假设第i个杯子已满，向其倒水，多余的水会正正好好流向第i+1个杯子（如果i=n时没有下一个杯子，不会有杯子接住此时多余的水而溢出到魔法训练室的水池）。这些杯子有着初始固定的水量，每次练习后杯子里的水都会还原到最初状态。每次练习时，魔法黑板会告诉小美需要将哪一个杯子倒满水。因为每个杯子的材质和形状有所不同，所以对其释放倒水魔法需要消耗的魔法值不同。小美想尽可能多练习，所以需要最小化每次消耗的魔法值的总量。</p><p>输入描述：</p><p>第一行一个整数n，表示杯子数量。 第二行n个整数x1,x2,...,xn，依次表示第i 个杯子能容纳水的量（单位为毫升）。第三行n个整数y1,y2,...,yn，依次表示第 i个杯子初始有的水量（单位为毫升）。第四行n个整数z1,z2,...,zn，依次表示对第 i个杯子每添加1毫升水需要消耗的法力值。 第五行一个整数m，表示练习的数量。第六行m个整数q1,q2,...,qm，依次表示第i次练习时需要将第qi个杯子倒满。（每次练习过后，杯子里的水量都会还原为初始状态，不会影响到下一次练习）1≤n,m≤3000 , 1≤yi≤xi≤109, 1≤zi≤300,1≤qi≤n 输出描述输出第一行m个数，依次表示每次训练时需要消耗的最小法力值。如果杯子初始本身就是满的，则需要消耗的法力值为0。</p><p>样例输入：</p><p>3</p><p>1 2 3</p><p>1 1 2</p><p>1 2 5</p><p>2</p><p>3 1</p><p>样例输出：</p><p>2 0</p><p>提示 ：</p><p>样例解释 第一次训练，最优方案如下： 初始时杯子的水量和最大容量分别为1/1 1/2 2/3 1.给1号杯子（本身已满）倒水1毫升，消耗1点法力，水溢出转移到2号杯子，当前状态为1/1 2/2 2/3 2.继续给1号杯子（本身已满）倒水1毫升，消耗1点法力，水溢出到2号杯子（也已满），继续溢出到3号杯子,此时3号杯子也被成功注满水，状态为：1/1 2/2 3/3 共消耗2点法力。可以证明没有更优方案。 第二次训练时，初始时杯子的水量和最大容量分别为（注意不同训练互不影响，因为训练结束后魔法会让水杯还原为初始状态）1/1 1/2 2/3 可以发现1号杯子已满，不用注水，消耗法力为0。</p><p>题解：</p><p>维护一个两个水杯的差也就是前缀和，前缀和的优点是，便于计算区间的差值，只需要维护好这个差值的前缀和就好了</p><p>本题的前缀和计算方式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br><span class="hljs-comment">// 前缀和数组比原来的数组长度多1，这里是计算两个数组差值的前缀和，因此只需要将前面的和与当前的差</span><br>            PreSum[i+<span class="hljs-number">1</span>] = PreSum[i] + Capacity[i] - InitCapacity[i];<br>        &#125;<br></code></pre></td></tr></table></figure><p>完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">cin</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> cin.nextInt();<br><br>        <span class="hljs-type">int</span>[] Capacity = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-type">int</span>[] InitCapacity = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-type">int</span>[] Cost = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-type">int</span>[] PreSum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n+<span class="hljs-number">1</span>];<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; Capacity.length; i++) &#123;<br>            Capacity[i] = cin.nextInt();<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; InitCapacity.length; i++) &#123;<br>            InitCapacity[i] = cin.nextInt();<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; Cost.length; i++) &#123;<br>            Cost[i] = cin.nextInt();<br>        &#125;<br>        <span class="hljs-comment">//compute preSum</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            PreSum[i+<span class="hljs-number">1</span>] = PreSum[i] + Capacity[i] - InitCapacity[i];<br>        &#125;<br>        <span class="hljs-comment">//deal logic</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> cin.nextInt();<br>        <span class="hljs-type">int</span>[] operatorTimes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m];<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; operatorTimes.length; i++) &#123;<br>            operatorTimes[i] = cin.nextInt();<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">times</span> <span class="hljs-operator">=</span> operatorTimes[i];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; times; j++) &#123;<br>                res = Math.min(res , (PreSum[times] - PreSum[j])*Cost[j]);<br>            &#125;<br>            System.out.println(res);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="t5">T5</h3><p>题目描述：</p><p>你现在有一棵树，树上的每个节点都有自己的价值。价值的计算规则如下所示：① 若某节点N没有儿子节点，那么节点N价值为1； ②若某节点N有两个儿子节点，那么节点N价值为两个儿子节点的价值之和，或者价值之按位异或。这取决于节点N的颜色，若N的颜色为红色，那么节点N价值为两个儿子节点的价值之和；若N的颜色为绿色，那么节点N价值为两个儿子节点的价值之按位异或。保证这棵树要么没有儿子节点，要么有两个儿子节点。注：树，是一种无向无环联通图。按位运算就是基于整数的二进制表示进行的运算。按位异或用符号⊕表示，两个对应位不同时为1，否则为0。如： 5=(101)2 6=(110)2 5⊕6=3，即 (101)2 ⊕ (110)2 = (011)2</p><p>输入描述：</p><p>第一行一个正整数n表示节点个数。 第二行n-1个正整数p<ahref="2≤i≤n">i</a>表示第 i 个节点的父亲。1号节点是根节点。第三行n个整数c<a href="1≤i≤n">i</a>，当c[i] = 1时表示第 i个节点是红色，c[i] = 2则表示绿色。 数据保证形成合法的树。对于所有的数据，n≤50000</p><p>输出描述：</p><p>输出一行一个整数表示根节点的值。</p><p>样例输入</p><p>3</p><p>1 1</p><p>2 2 2</p><p>样例输出 0</p><p>提示：</p><p>样例如图所示。 因为2号节点和3号节点都没有儿子，因此值都为1。因为1号节点的颜色是绿色，因此1号节点的值是2号节点的值和3号节点的按位异或，为0。</p><p>题解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">five</span> &#123;<br>    <span class="hljs-comment">//用map描述父子关系，再深度优先搜索</span><br>    <span class="hljs-keyword">static</span> Map&lt;Integer , List&lt;Integer&gt;&gt; rootChild = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-keyword">static</span> Map&lt;Integer , Integer&gt; color = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">cin</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> cin.nextInt();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; <span class="hljs-comment">//???</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++, id++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> cin.nextInt();<br>            List&lt;Integer&gt; child = rootChild.get(root);<br>            <span class="hljs-keyword">if</span> (child == <span class="hljs-literal">null</span>)&#123;<br>                child = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            &#125;<br>            child.add(id);<br>            rootChild.put(root , child);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            color.put(i + <span class="hljs-number">1</span> , cin.nextInt());<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> dfs(<span class="hljs-number">1</span>);<br>        System.out.println(res);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>        <span class="hljs-keyword">if</span> (!rootChild.containsKey(i))&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        List&lt;Integer&gt; childs = rootChild.get(i);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> childs.get(<span class="hljs-number">0</span>) , right = childs.get(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (color.get(left) == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> dfs(left) +dfs(right);<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> dfs(left)^dfs(right);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>2024暑期实习笔试</category>
      
      <category>美团</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>63. 不同路径 Ⅱ</title>
    <link href="/2023/03/30/63-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84-%E2%85%A1/"/>
    <url>/2023/03/30/63-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84-%E2%85%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="链接">[链接🚀]</h2><h3 id="题目">题目</h3><figure><img src="../img/md/leetcode/63.png" alt="63" /><figcaption aria-hidden="true">63</figcaption></figure><h3 id="题解">题解</h3><ul><li>与上题一样，但是在处理障碍物时应当先判断障碍物是否等于0，然后再开始进行遍历 ### 代码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">uniquePathsWithObstacles</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] obstacleGrid)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> obstacleGrid.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> obstacleGrid[<span class="hljs-number">0</span>].length;<br><br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br>        <span class="hljs-comment">// 终点应该是m-1 , n-1</span><br>        <span class="hljs-keyword">if</span> (obstacleGrid[m-<span class="hljs-number">1</span>][n-<span class="hljs-number">1</span>] == <span class="hljs-number">1</span> || obstacleGrid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// dp init , column</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m &amp;&amp; obstacleGrid[i][<span class="hljs-number">0</span>] != <span class="hljs-number">1</span> ; i++) &#123;<br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// dp init row</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n &amp;&amp; obstacleGrid[<span class="hljs-number">0</span>][j] != <span class="hljs-number">1</span> ; j++) &#123;<br>            dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// start traverse</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; m ; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; n ; j++) &#123;<br>                dp[i][j] = (obstacleGrid[i][j] == <span class="hljs-number">0</span>) ? dp[i-<span class="hljs-number">1</span>][j] + dp[i][j-<span class="hljs-number">1</span>] : <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dp[m-<span class="hljs-number">1</span>][n-<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>62. 不同路径</title>
    <link href="/2023/03/30/62-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/"/>
    <url>/2023/03/30/62-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/</url>
    
    <content type="html"><![CDATA[<h2 id="链接">[链接🚀]</h2><h3 id="题目">题目</h3><figure><img src="../img/md/leetcode/62.png" alt="62" /><figcaption aria-hidden="true">62</figcaption></figure><h3 id="题解">题解</h3><ul><li>定义dp数组，该数组代表着路径的个数</li><li>dp数组的递推公式，dp[i][j] = dp[i-1][j] + dp[i][j-1];</li><li>初始化，第一列初始化为1，第一行初始化为1；</li><li>遍历方式，需要从左往右遍历和从上往下遍历</li><li>打印 ### 代码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">    定义 dp数组</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-comment">// define a dynamic arrays</span><br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n]; <span class="hljs-comment">// path sum</span><br>        <span class="hljs-comment">// initial  dp arrays</span><br>        <span class="hljs-comment">// initial first column</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m ; i++) &#123;<br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">// initial first row</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; j &lt; n ; j++) &#123;<br>            dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//遍历方式</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; m ; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>                dp[i][j] = dp[i-<span class="hljs-number">1</span>][j] + dp[i][j-<span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dp[m-<span class="hljs-number">1</span>][n-<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>746. 使用最小花费爬楼梯</title>
    <link href="/2023/03/11/746-%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF/"/>
    <url>/2023/03/11/746-%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF/</url>
    
    <content type="html"><![CDATA[<h2 id="链接"><ahref="https://leetcode.cn/problems/min-cost-climbing-stairs/">链接🚀</a></h2><h3 id="题目">题目</h3><figure><img src="../img/md/leetcode/746.png" alt="746" /><figcaption aria-hidden="true">746</figcaption></figure><h3 id="题解">题解</h3><h3 id="代码">代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minCostClimbingStairs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] cost)</span> &#123;<br>        <br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> cost.length;<br>        <br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[length + <span class="hljs-number">1</span>];<br>        <br>        <span class="hljs-comment">/*init dp array*/</span><br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-comment">/*traversal arrays*/</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= length; i++) &#123;<br>            dp[i] = Math.min(dp[i - <span class="hljs-number">1</span>] + cost[i - <span class="hljs-number">1</span>] , dp[i - <span class="hljs-number">2</span>] + cost[i - <span class="hljs-number">2</span>]);<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> dp[length];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>70. 爬楼梯</title>
    <link href="/2023/03/11/70-%E7%88%AC%E6%A5%BC%E6%A2%AF/"/>
    <url>/2023/03/11/70-%E7%88%AC%E6%A5%BC%E6%A2%AF/</url>
    
    <content type="html"><![CDATA[<h2 id="链接"><ahref="https://leetcode.cn/problems/climbing-stairs/">链接🚀</a></h2><h3 id="题目">题目</h3><figure><img src="../img/md/leetcode/455.png" alt="455" /><figcaption aria-hidden="true">455</figcaption></figure><h3 id="题解">题解</h3><p>按照程序员卡尔的递归五部曲： 1、定义dp数据，并阐明含义2、确定动态规划的递推公式 - 本题： - 假如n = 1 , n_tiems = 1; - 假如n =2 , n_tiems = 2; - 假如n = 3 , n_tiems = 3; - 假如n = 4 , n_tiems = 5; -假如n = 5 , n_tiems = 8; 递推公式：dp[i] = dp[i-1] + dp[1-2];3、确定动态规划的初始化这里先定义一个dp数组长度为n+1，之所以是n+1是因为数组是从0开始计数的因此数组中第n+1位的值刚好就是我们需要返回的n个台阶所返回的值；<br />然后就是dp[1] = 1;<br />dp[2] = 2;<br />之所以不从dp[0]开始初始化的原因是，即使初始化dp[0]也是没有意义的；<br />4、确定遍历顺序 也是从前往后遍历 5、打印数组 ### 代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">climbStairs</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-comment">/**recurrence formula: dp[i] = dp[i-1] + dp[i-2]</span><br><span class="hljs-comment">        * init dp[] array</span><br><span class="hljs-comment">        * */</span> <br>        <span class="hljs-comment">// boundary condition</span><br>        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">3</span>) &#123;<br>            <span class="hljs-keyword">return</span> n;<br>        &#125;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n+<span class="hljs-number">1</span>];<br>        <span class="hljs-comment">/*init dp[];*/</span><br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>; i &lt;= n; i++) &#123;<br>            dp[i] = dp[i-<span class="hljs-number">1</span>] + dp[i-<span class="hljs-number">2</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>509. 斐波那契数</title>
    <link href="/2023/03/11/509-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0/"/>
    <url>/2023/03/11/509-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="链接"><ahref="https://leetcode.cn/problems/fibonacci-number/">链接🚀</a></h2><h3 id="题目">题目</h3><figure><img src="../img/md/leetcode/455.png" alt="455" /><figcaption aria-hidden="true">455</figcaption></figure><h3 id="题解">题解</h3><p>参考程序员卡尔的题解，动态规划五部曲 ### 代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-comment">/*1.define a dp[i] : the meanning is : 第 i个斐波拉契数的值*/</span><br>        <span class="hljs-comment">/*2.how to determine the recurremce formula dp[n] = dp[n - 1] + dp[n - 2]*/</span><br>        <span class="hljs-comment">/*3.how to init a dp[i] ;dp[0] = 0 ; dp[1] = 1;*/</span><br>        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">return</span> n;<br>        &#125;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">/*4.how to traversal order*/</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>            dp[i] = dp[i-<span class="hljs-number">1</span>] + dp[i-<span class="hljs-number">2</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>        <span class="hljs-comment">/*5.print dp[] array*/</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 24. 反转链表</title>
    <link href="/2023/03/10/%E5%89%91%E6%8C%87-Offer-24-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <url>/2023/03/10/%E5%89%91%E6%8C%87-Offer-24-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="链接"><ahref="https://leetcode.cn/problems/fan-zhuan-lian-biao-lcof/">链接🚀</a></h2><h3 id="题目">题目</h3><figure><img src="../img/md/leetcode/j24.png" alt="j24" /><figcaption aria-hidden="true">j24</figcaption></figure><h3 id="题解">题解</h3><p>踩坑：当将head.next赋予给concrrentNode时 ### 代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">conrrentNode</span> <span class="hljs-operator">=</span> head.next; <span class="hljs-comment">// define a current node</span><br>        head.next = <span class="hljs-literal">null</span>;<span class="hljs-comment">//tips : let head.next = null , if not , we traverse the list ,the head.next still origin value</span><br>        ListNode temp; <span class="hljs-comment">//temp node for store listnode.next</span><br>        <span class="hljs-keyword">while</span> (conrrentNode != <span class="hljs-literal">null</span>) &#123;<br>            temp = conrrentNode.next;<br>            conrrentNode.next = head;<br>            head = conrrentNode;<br>            conrrentNode = temp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>剑指offerⅡ</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 10- I. 斐波那契数列</title>
    <link href="/2023/03/10/%E5%89%91%E6%8C%87-Offer-10-I-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/"/>
    <url>/2023/03/10/%E5%89%91%E6%8C%87-Offer-10-I-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h2 id="链接"><ahref="https://leetcode.cn/problems/fei-bo-na-qi-shu-lie-lcof/">链接🚀</a></h2><h3 id="题目">题目</h3><figure><img src="../img/md/leetcode/j10.png" alt="j10" /><figcaption aria-hidden="true">j10</figcaption></figure><h3 id="题解">题解</h3><p>见题解:采用递归方式竟然超过时间限制； ### 代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MOD</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000000007</span>;<br>        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">return</span> n;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, q = <span class="hljs-number">0</span>, r = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= n; ++i) &#123;<br>            p = q; <br>            q = r; <br>            r = (p + q) % MOD;<br>        &#125;<br>        <span class="hljs-keyword">return</span> r;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>剑指offerⅡ</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 09. 用两个栈实现队列</title>
    <link href="/2023/03/10/%E5%89%91%E6%8C%87-Offer-09-%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
    <url>/2023/03/10/%E5%89%91%E6%8C%87-Offer-09-%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h2 id="链接"><ahref="https://leetcode.cn/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/">链接🚀</a></h2><h3 id="题目">题目</h3><figure><img src="../img/md/leetcode/j09.png" alt="j09" /><figcaption aria-hidden="true">j09</figcaption></figure><h3 id="题解">题解</h3><p>见注释 ### 代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CQueue</span> &#123;<br><br>   <span class="hljs-comment">/*用两个栈模拟一个队列的情况*/</span><br>    Deque&lt;Integer&gt; inDeque;<br>    Deque&lt;Integer&gt; outDeque;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CQueue</span><span class="hljs-params">()</span> &#123;<br>        inDeque = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;Integer&gt;();<br>        outDeque = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;Integer&gt;();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">appendTail</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>        inDeque.push(value);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">deleteHead</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//先判断出栈中是否为空</span><br>        <span class="hljs-keyword">if</span> (outDeque.isEmpty()) &#123;<br>            <span class="hljs-comment">//再判断入栈中是否为空</span><br>            <span class="hljs-keyword">if</span> (inDeque.isEmpty()) &#123;<br>                <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>            &#125;<br>            appendTail1();<span class="hljs-comment">//将入栈中的元素输入到出栈中</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> outDeque.pop();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">appendTail1</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span> (!inDeque.isEmpty())&#123;<br>            outDeque.push(inDeque.pop());<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your CQueue object will be instantiated and called as such:</span><br><span class="hljs-comment"> * CQueue obj = new CQueue();</span><br><span class="hljs-comment"> * obj.appendTail(value);</span><br><span class="hljs-comment"> * int param_2 = obj.deleteHead();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>剑指offerⅡ</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 07. 重建二叉树</title>
    <link href="/2023/03/09/%E5%89%91%E6%8C%87-Offer-07-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2023/03/09/%E5%89%91%E6%8C%87-Offer-07-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h2 id="链接">[链接🚀]</h2><h3 id="题目">题目()</h3><figure><img src="../img/md/leetcode/j07.png" alt="j07" /><figcaption aria-hidden="true">j07</figcaption></figure><h3 id="题解">题解</h3><p>与之前的105题目是一样的，但是在本题中，我重新分析了在递归时，前序序列的区间，中序序列的区间；见代码注释 ### 代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>   Map&lt;Integer , Integer&gt; map;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">buildTree</span><span class="hljs-params">(<span class="hljs-type">int</span>[] preorder, <span class="hljs-type">int</span>[] inorder)</span> &#123;<br>        map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; inorder.length; i++) &#123;<br>            map.put(inorder[i] , i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> PreAndInbuild(preorder , <span class="hljs-number">0</span> , preorder.length , inorder , <span class="hljs-number">0</span> , inorder.length);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">PreAndInbuild</span><span class="hljs-params">(<span class="hljs-type">int</span>[] preorder , <span class="hljs-type">int</span> preBegin , <span class="hljs-type">int</span> preEnd,</span><br><span class="hljs-params">                                  <span class="hljs-type">int</span>[] inorder , <span class="hljs-type">int</span> inBegin , <span class="hljs-type">int</span> inEnd)</span> &#123;<br><br>        <span class="hljs-keyword">if</span> (preBegin &gt;= preEnd || inBegin &gt;= inEnd) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">rootIndex</span> <span class="hljs-operator">=</span> map.get(preorder[preBegin]); <span class="hljs-comment">//拿到二叉树根的值载中序序列中的索引；</span><br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(inorder[rootIndex]);<span class="hljs-comment">//创建二叉树</span><br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">leftOf</span> <span class="hljs-operator">=</span> rootIndex - inBegin; <br>        <span class="hljs-comment">//中序序列的左子树,rootIndex用于分割中序数组</span><br>        <span class="hljs-comment">//中序序列的左子树的区间自然就是[inBegin,rootIndex],中序序列的右子树自然就  是[rootIndex+1 , inEnd]</span><br>        <span class="hljs-comment">//而前序序列中确定根节点的值，每用一次，相应的区间就应该是右移，所以在确定前序序列的区间，我们应当有一个加1</span><br><br>        root.left = PreAndInbuild(preorder , preBegin + <span class="hljs-number">1</span> , preBegin + leftOf + <span class="hljs-number">1</span> , inorder , inBegin , rootIndex);<br><br>        root.right = PreAndInbuild(preorder , preBegin + leftOf + <span class="hljs-number">1</span> , preEnd , inorder , rootIndex + <span class="hljs-number">1</span> , inEnd);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>剑指offerⅡ</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 06. 从尾到头打印链表</title>
    <link href="/2023/03/08/%E5%89%91%E6%8C%87-Offer-06-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/"/>
    <url>/2023/03/08/%E5%89%91%E6%8C%87-Offer-06-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="链接"><ahref="https://leetcode.cn/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/">链接🚀</a></h2><h3 id="题目">题目</h3><figure><img src="../img/md/leetcode/j06.png" alt="j06" /><figcaption aria-hidden="true">j06</figcaption></figure><h3 id="题解">题解</h3><p>见注解 ### 代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*剑指 Offer 06. 从尾到头打印链表</span><br><span class="hljs-comment">    * method:</span><br><span class="hljs-comment">    * 1、反转链表，将指针依次修改，初始化一个数组，用于保存链表的结果</span><br><span class="hljs-comment">    * 2、修改链表的指针，从尾指针开始修改</span><br><span class="hljs-comment">    * */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] reversePrint(ListNode head) &#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">int</span>[] resnull = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[];<br>            <span class="hljs-keyword">return</span> resnull;<br>        &#125;<br><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> head.next;<br>        ListNode temp;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (current!= <span class="hljs-literal">null</span>) &#123;<br>            temp = current.next;<br>            current.next = head;<br>            head = current;<br>            current = temp;<span class="hljs-comment">//这里就已经在移动</span><br>            length++;<br>        &#125;<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[length];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (head != <span class="hljs-literal">null</span>) &#123;<br>                res[i] = head.val;<br>            &#125;<br>            head = head.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-comment">/*method1:</span><br><span class="hljs-comment">    * 1、不用反转链表，先遍历得到链表的长度</span><br><span class="hljs-comment">    * 2、初始化一个与链表等长的数组，然后将数组从后往前填入数据；</span><br><span class="hljs-comment">    * */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] reversePrint1(ListNode head) &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (head != <span class="hljs-literal">null</span>) &#123;<br>            length++;<br>            head = head.next;<br>        &#125;<br><br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[length];<br>        <span class="hljs-keyword">while</span> (current != <span class="hljs-literal">null</span>) &#123;<br>            res[length-<span class="hljs-number">1</span>] = current.val;<br>            length--;<br>            current = current.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>剑指offerⅡ</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 04.二维数组中的查找</title>
    <link href="/2023/03/08/%E5%89%91%E6%8C%87-Offer-04-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/"/>
    <url>/2023/03/08/%E5%89%91%E6%8C%87-Offer-04-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="链接"><ahref="https://leetcode.cn/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/">链接🚀</a></h2><h3 id="题目">题目</h3><figure><img src="../img/md/leetcode/j04.png" alt="j04" /><figcaption aria-hidden="true">j04</figcaption></figure><h3 id="题解">题解</h3><h3 id="代码">代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*剑指 Offer 04. 二维数组中的查找</span><br><span class="hljs-comment">    * method1:</span><br><span class="hljs-comment">    * 暴力查找</span><br><span class="hljs-comment">    * 对二维矩阵中的每一个元素都进行遍历并比较</span><br><span class="hljs-comment">    * */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">findNumberIn2DArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] row : matrix) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> element : row) &#123;<br>                <span class="hljs-keyword">if</span> (element == target) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/*method2:</span><br><span class="hljs-comment">    * 因为矩阵中的每一行都是递增的，因此我们可以考虑在元素的每一行采用二分查找来寻找目标元素</span><br><span class="hljs-comment">    * */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">findNumberIn2DArray2</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] row : matrix) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> BinarySearch(row , target);<br>            <span class="hljs-keyword">if</span> (index &gt;= <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/*二分查找思路：</span><br><span class="hljs-comment">    * 1、定义两个左右指针，分别只想元素的头和尾</span><br><span class="hljs-comment">    * 2、当左指针小于右指针时，确定中位值用 int num = (right-left) / 2 +left;</span><br><span class="hljs-comment">    * 3、若num等于target则返回该目标值的下标</span><br><span class="hljs-comment">    * 4、若num大于target则应该将右指针左移否则左直接右移</span><br><span class="hljs-comment">    * */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">BinarySearch</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums , <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> , right = nums.length-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">middleIndex</span> <span class="hljs-operator">=</span> (right - left) / <span class="hljs-number">2</span> +left;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">middleValue</span> <span class="hljs-operator">=</span> nums[middleIndex];<br>            <span class="hljs-keyword">if</span> (middleValue == target) &#123;<br>                <span class="hljs-keyword">return</span> middleIndex;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (middleValue &gt; target) &#123;<br>                right = middleIndex - <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                left = middleIndex + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>剑指offerⅡ</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 03. 数组中重复的数字</title>
    <link href="/2023/03/08/%E5%89%91%E6%8C%87-Offer-03-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <url>/2023/03/08/%E5%89%91%E6%8C%87-Offer-03-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<h2 id="链接"><ahref="https://leetcode.cn/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/?favorite=xb9nqhhg">链接🚀</a></h2><h3 id="题目">题目</h3><figure><img src="../img/md/leetcode/j03.png" alt="j03" /><figcaption aria-hidden="true">j03</figcaption></figure><h3 id="题解">题解</h3><p>见代码注释 ### 代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">/*剑指 Offer 03. 数组中重复的数字</span><br><span class="hljs-comment">    * method1:利用Hashset的特性，set集合是无序、不可重复的，因此在添加元素相同时，add返回false;</span><br><span class="hljs-comment">    * Hashset检查重复元素：底层调用的是Hashmap的Put方法，获取待添加对象的Hashcode值，然后再利用equals()方法判断元素是否相同</span><br><span class="hljs-comment">    * */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findRepeatNumber</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br><br>        Set&lt;Integer&gt; hashSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">repeatValue</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            <span class="hljs-keyword">while</span> (!hashSet.add(num))&#123;<br>                repeatValue = num;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> repeatValue;<br>    &#125;<br><br>    <span class="hljs-comment">/*method2:</span><br><span class="hljs-comment">    * 1、将元素排序</span><br><span class="hljs-comment">    * 2、遍历数组，判断相邻元素是否一样，若一样则返回</span><br><span class="hljs-comment">    * */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findRepeatNumber2</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        Arrays.sort(nums);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] == nums[i-<span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-keyword">return</span> nums[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>剑指offerⅡ</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>智能旅游推荐系统-项目介绍及遇到的相关问题记录</title>
    <link href="/2023/03/02/%E6%99%BA%E8%83%BD%E6%97%85%E6%B8%B8%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D%E5%8F%8A%E9%81%87%E5%88%B0%E7%9A%84%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <url>/2023/03/02/%E6%99%BA%E8%83%BD%E6%97%85%E6%B8%B8%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D%E5%8F%8A%E9%81%87%E5%88%B0%E7%9A%84%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="智能旅游推荐系统">智能旅游推荐系统</h1><p><strong>项目简介：</strong>该项目是一款应用于旅游推荐的业务系统，用户可以从网站浏览推荐的地点，浏览非疫情地区的旅游情况。后台实现对旅游景点的管理，游客信息的管理，用户权限的管理，预约订单的查询，预约条件的设置和运营情况的可视化。从而提高旅游推荐的效率，为用户提供更精准，更安全的旅游推荐服务。<br /><strong>技术选型：</strong>Spring、SpringMVC、MyBatis、SpringSecurity、Vue、Ajax、MySQL。<br /><strong>负责工作：</strong><br />1.用户注册登录模块：前后台登录的实现以及后台登录后根据管理员权限动态展示菜单的实现。<br />我遇到了以下问题：<br /><strong>跨域问题</strong><br />由于Vue是运行在前台的，而本项目运行在后端服务器上，因此发生了跨域问题，在网络上查找过相关的资料，比如在Vue的config文件目录下有个index文件，修改proxy;但是这种方式只能在开发环境中使用。<br />结合本项目的实际情况，考虑在spring项目中添加跨域资源访问CROS，以运行其他域名或端口的Web应用程序访问服务器上的资源；考虑是使用@CrossOrigin注解，实现指定方法的跨域资源的访问请求，但是它所带来的问题有几个方面，首先不够灵活，因为它是定义在方法上的，其次它无法用于Servlet过滤器，另外它还会带来时间开销，因为每次请求都会进行一次跨域检查。<br />那么考虑到灵活度，我们通过配置CROS的过滤器，以便在整个应用程序中实现跨域访问。比如以下示例中允许使用GET、POST、PUT、DELETE方法请求资源。<br />后台用户角色权限管理是通过RBAC模型进行设计的，有用户表，角色表，菜单表，用户角色表，角色菜单表五张表，用户可以有多种角色，不同的角色对应着不同的菜单；<br /><strong>（后期优化）</strong>如果有大量的跨域请求的话可以考虑使用反向代理服务器，nginx，它可以实现访问控制（基于ip地址和http请求头部授权策略，比如将token封装到请求头中）、请求转发和路由（转发到不同的后端服务器中）、缓存控制（将服务器中的静态资源缓存到反向代理服务器中，避免重复请求，提高性能。）和安全控制（基于SSL证书）。<br /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CorsConfig</span> &#123;<br> <br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> WebMvcConfigurer <span class="hljs-title function_">corsConfigurer</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebMvcConfigurer</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addCorsMappings</span><span class="hljs-params">(CorsRegistry registry)</span> &#123;<br>                registry.addMapping(<span class="hljs-string">&quot;/**&quot;</span>)<br>                    .allowedOrigins(<span class="hljs-string">&quot;http://localhost:8080&quot;</span>)<br>                    .allowedMethods(<span class="hljs-string">&quot;GET&quot;</span>, <span class="hljs-string">&quot;POST&quot;</span>, <span class="hljs-string">&quot;PUT&quot;</span>, <span class="hljs-string">&quot;DELETE&quot;</span>);<br>            &#125;<br>        &#125;;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure> <strong>接口设计问题</strong>用户登录成功之后需要保存用户的状态，http协议是无状态的，因此我们在后端生成一个token字符串，然后把返回的token值放到cookies里面，但是另外开其一个窗口时访问时就无法登录成功，那么我们将这个token封装到请求头中后发送；那么用户就可以共享登录信息了</p><p><strong>数据校验问题</strong>用户注册登录，为了防止用户输出不合法的数据，我们在vue端做了登录的数据校验，同时我们也在后端做了数据校验，使用了Javabean Validation中注解定义验证规则；使用@Validate注解和<spanclass="citation"data-cites="ExceptionHanlder注解统一地到控制器中处理">@ExceptionHanlder注解统一地到控制器中处理</span>。</p><p><strong>密码加密问题</strong> 为了保证用户的安全性，我们采用SpringSecurity框架中的BCrypt加密算法来对用户密码进行保护，引入依赖--&gt;添加configuration来实例化一个BCryptPasswordEncoder对象--&gt;利用encode方法进行加密--&gt;存储到数据库中；</p><p><strong>前后端交互问题</strong></p><p>由于前期设计中并没有遵守api的设计规范，接口量上来之后常常把前端的ajax请求模糊不清，因此后期采用了RESTFUL的相关约定，让api阅读简洁明了；</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>738. 单调递增的数字</title>
    <link href="/2023/02/25/738-%E5%8D%95%E8%B0%83%E9%80%92%E5%A2%9E%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <url>/2023/02/25/738-%E5%8D%95%E8%B0%83%E9%80%92%E5%A2%9E%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<h2 id="链接">[链接🚀]</h2><h3 id="题目">题目</h3><figure><img src="img/md/leetcode/738.png" alt="738" /><figcaption aria-hidden="true">738</figcaption></figure><h3 id="题解">题解</h3><p>这里需要从后往前遍历，是为了避免当从前往后遍历是出现如443，修改之后变为433的情况，正确的应该是399；</p><p>遍历过程中所做的优化就是将从开始i设置为长度-1 ， 则比较时就可以用 i&gt; i + 1;方便阅读；</p><h3 id="代码">代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">monotoneIncreasingDigits</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-comment">/*转换为字符串*/</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> String.valueOf(n);<br>        <span class="hljs-comment">/*转换为字符数组*/</span><br>        <span class="hljs-type">char</span>[] chars = s.toCharArray();<br>        <span class="hljs-comment">/*设置转换为9的标记位*/</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> chars.length;<br>        <span class="hljs-comment">/*开始遍历*/</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> chars.length - <span class="hljs-number">2</span>; i  &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-comment">/*从后往前遍历数字数组，若遇到非递增的情况则将前一个数--，后一个数先标记，最后再用for循环统一修改*/</span><br>            <span class="hljs-keyword">if</span> (chars[i] &gt; chars[i+<span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-comment">/*前一个数--*/</span><br>                chars[i]--;<br>                <span class="hljs-comment">/*后一个数先标记*/</span><br>                flag = i+<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">/*从flag标记位开始遍历，将数字改为统一的9*/</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> flag; i &lt; chars.length; i++) &#123;<br>            chars[i] = <span class="hljs-string">&#x27;9&#x27;</span>;<br>        &#125;<br>        <span class="hljs-comment">/*将字符数组转换为整型数字并返回*/</span><br>        <span class="hljs-keyword">return</span> Integer.parseInt(String.valueOf(chars));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>贪心法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>56. 合并区间</title>
    <link href="/2023/02/25/56-%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4/"/>
    <url>/2023/02/25/56-%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4/</url>
    
    <content type="html"><![CDATA[<h2 id="链接">[链接🚀]</h2><h3 id="题目">题目</h3><figure><img src="../img/md/leetcode/56.png" alt="56" /><figcaption aria-hidden="true">56</figcaption></figure><h3 id="题解">题解</h3><p>本题巧妙之处在于确定左边最大右边界的值；当为重叠区间时，最大边界值为重叠区间右边的最大值，反复比较；</p><h3 id="代码">代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] merge(<span class="hljs-type">int</span>[][] intervals) &#123;<br><br>        Arrays.sort(intervals , (a , b) -&gt; Integer.compare(a[<span class="hljs-number">0</span>] , b[<span class="hljs-number">0</span>]));<br><span class="hljs-comment">//        System.out.println(intervals.toString());</span><br>        LinkedList&lt;<span class="hljs-type">int</span>[]&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> intervals[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]; <span class="hljs-comment">//开始</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">MaxRightBound</span> <span class="hljs-operator">=</span> intervals[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];<span class="hljs-comment">//右边界</span><br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; intervals.length; i++) &#123;<br>            <span class="hljs-comment">/*如果不重叠，则将重叠区间插入到链表中，首次插入时，start=interval[0][0] , MaxRightBound[i-1][1]*/</span><br>            <span class="hljs-keyword">if</span> (intervals[i][<span class="hljs-number">0</span>] &gt; MaxRightBound) &#123;<br>                list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;start , MaxRightBound&#125;);<br>                <span class="hljs-comment">//更新start , MaxRightBound</span><br>                start = intervals[i][<span class="hljs-number">0</span>];<br>                MaxRightBound = intervals[i][<span class="hljs-number">1</span>];<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-comment">/*当为重叠区间时，最大边界值为重叠区间右边的最大值，反复比较；*/</span>&#123;<br>                MaxRightBound = Math.max(MaxRightBound , intervals[i][<span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>        list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;start , MaxRightBound&#125;);<br>        <span class="hljs-keyword">return</span> list.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[list.size()][]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>贪心法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CF-协同过滤</title>
    <link href="/2023/02/25/CF-%E5%8D%8F%E5%90%8C%E8%BF%87%E6%BB%A4/"/>
    <url>/2023/02/25/CF-%E5%8D%8F%E5%90%8C%E8%BF%87%E6%BB%A4/</url>
    
    <content type="html"><![CDATA[<p>本系列参考王喆老师深度学习这本书构建自己的学习笔记。参考RoleRec基于Pytorch实现的相关推荐和CTR算法；</p><p>本小节将记录协调过滤算法，介绍它的目标场景、基本思想、相似度计算方式、基于User的协同过滤（UserCF）、基于Item的协同过滤(ItemCF)、以及UserCF和ItemCF的优缺点对比等等；</p><h2 id="目标场景">目标场景</h2><h2 id="基本思想">基本思想</h2><h2 id="相似度计算方式">相似度计算方式</h2><h2 id="基于user的协同过滤usercf">基于User的协同过滤（UserCF）</h2><h2 id="基于item的协同过滤itemcf">基于Item的协同过滤(ItemCF)</h2><h2 id="usercf和itemcf的优缺点对比">UserCF和ItemCF的优缺点对比</h2><h3 id="代码">代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>深度学习推荐系统</category>
      
      <category>机器学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>763. 划分字母区间</title>
    <link href="/2023/02/25/763-%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4/"/>
    <url>/2023/02/25/763-%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4/</url>
    
    <content type="html"><![CDATA[<h2 id="链接">[链接🚀]</h2><h3 id="题目">题目</h3><figure><img src="../img/md/leetcode/763.png" alt="763" /><figcaption aria-hidden="true">763</figcaption></figure><h3 id="题解">题解</h3><h3 id="代码">代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">partitionLabels</span><span class="hljs-params">(String s)</span> &#123;<br>        <br>        <span class="hljs-type">int</span>[] edge = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>];<span class="hljs-comment">//存储元素最后出现位置的</span><br><br>        <span class="hljs-type">char</span>[] sarray = s.toCharArray();<br><br>        LinkedList&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><br>        <span class="hljs-comment">//统计字符出现最后位置的索引，巧妙的是i不停地++操作 遇到相同的字符则更新最大值；</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; sarray.length; i++) &#123;<br>            edge[sarray[i] - <span class="hljs-string">&#x27;a&#x27;</span>] = i;<br>        &#125;<br>        System.out.println(Arrays.toString(edge));<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; sarray.length; i++) &#123;<br>            <span class="hljs-comment">//找到字符的最大边界 ， 这里就是贪心，贪心的是局部最大，用i == right作为局部最大的边界条件；</span><br>            right = Math.max(right, edge[sarray[i] - <span class="hljs-string">&#x27;a&#x27;</span>]);<br>            <span class="hljs-keyword">if</span> (i == right) &#123; <span class="hljs-comment">//找到最远边界</span><br>                list.add(right - left + <span class="hljs-number">1</span>);<br>                left = i +<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>贪心法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>435.无重叠区间</title>
    <link href="/2023/02/23/435-%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4/"/>
    <url>/2023/02/23/435-%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4/</url>
    
    <content type="html"><![CDATA[<h2 id="链接">[链接🚀]</h2><h3 id="题目">题目</h3><figure><img src="../img/md/leetcode/435.png" alt="435" /><figcaption aria-hidden="true">435</figcaption></figure><h3 id="题解">题解</h3><h3 id="代码">代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">eraseOverlapIntervals</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] intervals)</span> &#123;<br>      <span class="hljs-comment">//按照右边界排序</span><br>        Arrays.sort(intervals , (a , b) -&gt; Integer.compare(a[<span class="hljs-number">0</span>] , b[<span class="hljs-number">0</span>]));<br>        <br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; intervals.length; i++) &#123;<br>            <span class="hljs-comment">//判断是否为重叠区间 如果是重叠区间则continue,否则就count++</span><br>            <span class="hljs-keyword">if</span> (intervals[i][<span class="hljs-number">0</span>] &lt; intervals[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-comment">//重叠了则更新最右边界</span><br>                intervals[i][<span class="hljs-number">1</span>] = Math.min(intervals[i][<span class="hljs-number">1</span>] , intervals[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                count++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> intervals.length - count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>贪心法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>452. 用最少数量的箭引爆气球</title>
    <link href="/2023/02/23/452-%E7%94%A8%E6%9C%80%E5%B0%91%E6%95%B0%E9%87%8F%E7%9A%84%E7%AE%AD%E5%BC%95%E7%88%86%E6%B0%94%E7%90%83/"/>
    <url>/2023/02/23/452-%E7%94%A8%E6%9C%80%E5%B0%91%E6%95%B0%E9%87%8F%E7%9A%84%E7%AE%AD%E5%BC%95%E7%88%86%E6%B0%94%E7%90%83/</url>
    
    <content type="html"><![CDATA[<h2 id="链接">[链接🚀]</h2><h3 id="题目">题目</h3><figure><img src="../img/md/leetcode/452.png" alt="452" /><figcaption aria-hidden="true">452</figcaption></figure><h3 id="题解">题解</h3><p>利用sort排序后的序列，模拟出是否有重叠的情况如果无重叠count加1.如果重叠，则将最小值更新最右边界</p><h3 id="代码">代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findMinArrowShots</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] points)</span> &#123;<br>        <span class="hljs-comment">//首先利用Jdk自带的方法排序</span><br>        Arrays.sort(points , (a , b) -&gt; Integer.compare(a[<span class="hljs-number">0</span>] , b[<span class="hljs-number">0</span>]));<br><br>        <span class="hljs-comment">//模拟过程</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; points.length; i++) &#123;<br>            <span class="hljs-comment">//用前一个区间的最右元素和后一个区间的最左元素比较判断是否重叠，</span><br>            <span class="hljs-keyword">if</span> (points[i][<span class="hljs-number">0</span>] &gt; points[i -<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]) &#123;<br>                count++;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//更新重叠区间的最小右边界</span><br>                points[i][<span class="hljs-number">1</span>] = Math.min(points[i][<span class="hljs-number">1</span>] , points[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>贪心法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>406. 根据身高重建队列</title>
    <link href="/2023/02/23/406-%E6%A0%B9%E6%8D%AE%E8%BA%AB%E9%AB%98%E9%87%8D%E5%BB%BA%E9%98%9F%E5%88%97/"/>
    <url>/2023/02/23/406-%E6%A0%B9%E6%8D%AE%E8%BA%AB%E9%AB%98%E9%87%8D%E5%BB%BA%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h2 id="链接">[链接🚀]</h2><h3 id="题目">题目</h3><figure><img src="../img/md/leetcode/406.png" alt="406" /><figcaption aria-hidden="true">406</figcaption></figure><h3 id="题解">题解</h3><p>先按照身高排序，然后再按照ki来排序，这个排序的采用Array.sort函数来排序</p><h3 id="代码">代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.cy;<br><br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.LinkedList;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> 陈银</span><br><span class="hljs-comment"> * @$&#123;DAY_NAME_FULL&#125;</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@package</span> org.cy</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span> $&#123;DATE&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-type">int</span> array[][]  = &#123;&#123;<span class="hljs-number">7</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">4</span>,<span class="hljs-number">4</span>&#125;,&#123;<span class="hljs-number">7</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">5</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">6</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">5</span>,<span class="hljs-number">2</span>&#125;&#125;;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] data : reconstructQueue(array)) &#123;<br>            System.out.println(Arrays.toString(data));<br>        &#125;<br><br>        System.out.println(<span class="hljs-string">&quot;Hello world!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[][] reconstructQueue(<span class="hljs-type">int</span>[][] people) &#123;<br>        Arrays.sort(people , (a , b) -&gt;&#123;<br>            <span class="hljs-keyword">if</span> (a[<span class="hljs-number">0</span>] == b[<span class="hljs-number">0</span>]) &#123;<br>                <span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>] - b[<span class="hljs-number">1</span>];<br>            &#125;<br>            <span class="hljs-keyword">return</span> b[<span class="hljs-number">0</span>] - a[<span class="hljs-number">0</span>];<br>        &#125;);<br><br>        LinkedList&lt;<span class="hljs-type">int</span>[]&gt; que = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] p : people) &#123;<br>            que.add(p[<span class="hljs-number">1</span>] , p);<br>        &#125;<br>        <span class="hljs-keyword">return</span> que.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[people.length][]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>贪心法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>860. 柠檬水找零</title>
    <link href="/2023/02/22/860-%E6%9F%A0%E6%AA%AC%E6%B0%B4%E6%89%BE%E9%9B%B6/"/>
    <url>/2023/02/22/860-%E6%9F%A0%E6%AA%AC%E6%B0%B4%E6%89%BE%E9%9B%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="链接">[链接🚀]</h2><h3 id="题目">题目</h3><figure><img src="../img/md/leetcode/860.png" alt="860" /><figcaption aria-hidden="true">860</figcaption></figure><h3 id="题解">题解</h3><p>具体见代码注释</p><h3 id="代码">代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//对账单中的元素进行标记，手动模拟</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">lemonadeChange</span><span class="hljs-params">(<span class="hljs-type">int</span>[] bills)</span> &#123;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">five</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ten</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> bill : bills) &#123;<br>            <span class="hljs-comment">// 情况一：来的账单是等于5的</span><br>            <span class="hljs-keyword">if</span> (bill == <span class="hljs-number">5</span>) &#123;<br>                five++;<br>            &#125;<br>            <span class="hljs-comment">// 情况二：来的账单是等于10的 1. 先判断five的个数 若小于0 直接返回 否则就five-- ， ten++;</span><br>            <span class="hljs-keyword">if</span> (bill == <span class="hljs-number">10</span>) &#123;<br>                <span class="hljs-keyword">if</span> (five &lt;= <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>                five--;<br>                ten++;<br>            &#125;<br>            <span class="hljs-comment">// 情况三：来的账单是等于20的 1. 优先消耗掉10和5 于是先判断 ten和five的是否大于0若是 则将five和ten的值--</span><br>            <span class="hljs-comment">// 否则判断five的值是否大于等于3 成立的话就将five减3 否则返回false;</span><br>            <span class="hljs-keyword">if</span> (bill == <span class="hljs-number">20</span>) &#123;<br>                <span class="hljs-keyword">if</span> (five &gt; <span class="hljs-number">0</span> &amp;&amp; ten &gt; <span class="hljs-number">0</span>) &#123;<br>                    five--;<br>                    ten--;<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (five &gt;= <span class="hljs-number">3</span>) &#123;<br>                    five -=<span class="hljs-number">3</span>;<br>                &#125;<span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>贪心法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>快速排序</title>
    <link href="/2023/02/22/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <url>/2023/02/22/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="链接">[链接🚀]</h2><h3 id="题目">题目</h3><h3 id="题解">题解</h3><h3 id="代码">代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.cy.spring.sort;<br><br><span class="hljs-keyword">import</span> java.util.Arrays;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> 陈银</span><br><span class="hljs-comment"> * @星期三</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@package</span> org.cy.spring.sort</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span> 2023/2/22</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">QuickSort</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-type">int</span>[] array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">3</span> , <span class="hljs-number">1</span> ,<span class="hljs-number">0</span> , <span class="hljs-number">3</span> , <span class="hljs-number">9</span> , <span class="hljs-number">20</span> , <span class="hljs-number">19</span>&#125;;<br><br>        System.out.println(Arrays.toString(array));<br><br>        <span class="hljs-keyword">if</span> (array.length &gt; <span class="hljs-number">0</span>) &#123;<br>            sort(array , <span class="hljs-number">0</span> , array.length - <span class="hljs-number">1</span>);<br>        &#125;<br><br>        System.out.println(Arrays.toString(array));<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a , <span class="hljs-type">int</span> begain , <span class="hljs-type">int</span> end)</span> &#123;<br><br>        <span class="hljs-comment">//防止越界</span><br>        <span class="hljs-keyword">if</span> (begain &gt; end) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//以第一个元素为探测的基准值</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">BaseElemnt</span> <span class="hljs-operator">=</span> a[begain];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> begain;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> end;<br><br>        <span class="hljs-keyword">while</span> (j &gt; i) &#123;<br>            <span class="hljs-comment">/*j指针从右向左移动，若指针j移动时找到小于基准值时停下来*/</span><br>            <span class="hljs-keyword">while</span> (j &gt; i &amp;&amp; a[j] &gt; BaseElemnt) &#123;<br>                j--;<br>            &#125;<br>            <span class="hljs-comment">/*i指针从左往右移动，若指针i移动时找到大于基准值时停下来*/</span><br>            <span class="hljs-keyword">while</span> (j &gt; i &amp;&amp; a[i] &lt;= BaseElemnt) &#123;<br>                i++;<br>            &#125;<br>            <span class="hljs-comment">/*将j指针停下来所对应的值与i指针停下来所对应的值作交换，小的值放在前面，大的值放在后面*/</span><br>            <span class="hljs-keyword">if</span> (j &gt; i) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> a[i];<br>                a[i] = a[j];<br>                a[j] = temp;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">/*探测结束发生基准元素，i指针和j指针相遇，此时将基准元素和i指针所对应的值作交换*/</span><br>        a[begain] = a[i];<br>        a[i] = BaseElemnt;<br><br>        sort(a , begain , i - <span class="hljs-number">1</span>);<br>        sort(a , i + <span class="hljs-number">1</span> , end);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>贪心法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>冒泡排序</title>
    <link href="/2023/02/22/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    <url>/2023/02/22/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="链接">[链接🚀]</h2><h3 id="题目">题目</h3><h3 id="题解">题解</h3><h3 id="代码">代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.cy.spring.sort;<br><br><span class="hljs-keyword">import</span> java.util.Arrays;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> 陈银</span><br><span class="hljs-comment"> * @星期三</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@package</span> org.cy.spring.sort</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span> 2023/2/22</span><br><span class="hljs-comment"> 每次遍历后得到一个最大值，两个指针 ， 一个指针控制另外一个指针的遍历轮数</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BubbleSort</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-type">int</span>[] array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">3</span> , <span class="hljs-number">1</span> ,<span class="hljs-number">0</span> , <span class="hljs-number">3</span> , <span class="hljs-number">9</span> , <span class="hljs-number">20</span> , <span class="hljs-number">19</span>&#125;;<br>        <br>        System.out.println(Arrays.toString(array));<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> array.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; length - i; j++) &#123;<br>                <span class="hljs-keyword">if</span> (array[j - <span class="hljs-number">1</span>] &gt; array[j]) &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> array[j - <span class="hljs-number">1</span>];<br>                    array[j -<span class="hljs-number">1</span>] = array[j];<br>                    array[j] = temp;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <br>        System.out.println(Arrays.toString(array));<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>排序</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/02/20/Maven-%E5%85%A8%E5%B1%80%E9%85%8D%E7%BD%AE/"/>
    <url>/2023/02/20/Maven-%E5%85%A8%E5%B1%80%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<!DOCTYPE html><html><head>      <title>Maven-&#x5168;&#x5C40;&#x914D;&#x7F6E;</title>      <meta charset="utf-8">      <meta name="viewport" content="width=device-width, initial-scale=1.0">            <link rel="stylesheet" href="file:///c:\Users\Administrator\.vscode\extensions\shd101wyy.markdown-preview-enhanced-0.6.5\node_modules\@shd101wyy\mume\dependencies\katex\katex.min.css">                                                            <style>      /** * prism.js Github theme based on GitHub's theme. * @author Sam Clarke */code[class*="language-"],pre[class*="language-"] {  color: #333;  background: none;  font-family: Consolas, "Liberation Mono", Menlo, Courier, monospace;  text-align: left;  white-space: pre;  word-spacing: normal;  word-break: normal;  word-wrap: normal;  line-height: 1.4;  -moz-tab-size: 8;  -o-tab-size: 8;  tab-size: 8;  -webkit-hyphens: none;  -moz-hyphens: none;  -ms-hyphens: none;  hyphens: none;}/* Code blocks */pre[class*="language-"] {  padding: .8em;  overflow: auto;  /* border: 1px solid #ddd; */  border-radius: 3px;  /* background: #fff; */  background: #f5f5f5;}/* Inline code */:not(pre) > code[class*="language-"] {  padding: .1em;  border-radius: .3em;  white-space: normal;  background: #f5f5f5;}.token.comment,.token.blockquote {  color: #969896;}.token.cdata {  color: #183691;}.token.doctype,.token.punctuation,.token.variable,.token.macro.property {  color: #333;}.token.operator,.token.important,.token.keyword,.token.rule,.token.builtin {  color: #a71d5d;}.token.string,.token.url,.token.regex,.token.attr-value {  color: #183691;}.token.property,.token.number,.token.boolean,.token.entity,.token.atrule,.token.constant,.token.symbol,.token.command,.token.code {  color: #0086b3;}.token.tag,.token.selector,.token.prolog {  color: #63a35c;}.token.function,.token.namespace,.token.pseudo-element,.token.class,.token.class-name,.token.pseudo-class,.token.id,.token.url-reference .token.variable,.token.attr-name {  color: #795da3;}.token.entity {  cursor: help;}.token.title,.token.title .token.punctuation {  font-weight: bold;  color: #1d3e81;}.token.list {  color: #ed6a43;}.token.inserted {  background-color: #eaffea;  color: #55a532;}.token.deleted {  background-color: #ffecec;  color: #bd2c00;}.token.bold {  font-weight: bold;}.token.italic {  font-style: italic;}/* JSON */.language-json .token.property {  color: #183691;}.language-markup .token.tag .token.punctuation {  color: #333;}/* CSS */code.language-css,.language-css .token.function {  color: #0086b3;}/* YAML */.language-yaml .token.atrule {  color: #63a35c;}code.language-yaml {  color: #183691;}/* Ruby */.language-ruby .token.function {  color: #333;}/* Markdown */.language-markdown .token.url {  color: #795da3;}/* Makefile */.language-makefile .token.symbol {  color: #795da3;}.language-makefile .token.variable {  color: #183691;}.language-makefile .token.builtin {  color: #0086b3;}/* Bash */.language-bash .token.keyword {  color: #0086b3;}/* highlight */pre[data-line] {  position: relative;  padding: 1em 0 1em 3em;}pre[data-line] .line-highlight-wrapper {  position: absolute;  top: 0;  left: 0;  background-color: transparent;  display: block;  width: 100%;}pre[data-line] .line-highlight {  position: absolute;  left: 0;  right: 0;  padding: inherit 0;  margin-top: 1em;  background: hsla(24, 20%, 50%,.08);  background: linear-gradient(to right, hsla(24, 20%, 50%,.1) 70%, hsla(24, 20%, 50%,0));  pointer-events: none;  line-height: inherit;  white-space: pre;}pre[data-line] .line-highlight:before, pre[data-line] .line-highlight[data-end]:after {  content: attr(data-start);  position: absolute;  top: .4em;  left: .6em;  min-width: 1em;  padding: 0 .5em;  background-color: hsla(24, 20%, 50%,.4);  color: hsl(24, 20%, 95%);  font: bold 65%/1.5 sans-serif;  text-align: center;  vertical-align: .3em;  border-radius: 999px;  text-shadow: none;  box-shadow: 0 1px white;}pre[data-line] .line-highlight[data-end]:after {  content: attr(data-end);  top: auto;  bottom: .4em;}html body{font-family:"Helvetica Neue",Helvetica,"Segoe UI",Arial,freesans,sans-serif;font-size:16px;line-height:1.6;color:#333;background-color:#fff;overflow:initial;box-sizing:border-box;word-wrap:break-word}html body>:first-child{margin-top:0}html body h1,html body h2,html body h3,html body h4,html body h5,html body h6{line-height:1.2;margin-top:1em;margin-bottom:16px;color:#000}html body h1{font-size:2.25em;font-weight:300;padding-bottom:.3em}html body h2{font-size:1.75em;font-weight:400;padding-bottom:.3em}html body h3{font-size:1.5em;font-weight:500}html body h4{font-size:1.25em;font-weight:600}html body h5{font-size:1.1em;font-weight:600}html body h6{font-size:1em;font-weight:600}html body h1,html body h2,html body h3,html body h4,html body h5{font-weight:600}html body h5{font-size:1em}html body h6{color:#5c5c5c}html body strong{color:#000}html body del{color:#5c5c5c}html body a:not([href]){color:inherit;text-decoration:none}html body a{color:#08c;text-decoration:none}html body a:hover{color:#00a3f5;text-decoration:none}html body img{max-width:100%}html body>p{margin-top:0;margin-bottom:16px;word-wrap:break-word}html body>ul,html body>ol{margin-bottom:16px}html body ul,html body ol{padding-left:2em}html body ul.no-list,html body ol.no-list{padding:0;list-style-type:none}html body ul ul,html body ul ol,html body ol ol,html body ol ul{margin-top:0;margin-bottom:0}html body li{margin-bottom:0}html body li.task-list-item{list-style:none}html body li>p{margin-top:0;margin-bottom:0}html body .task-list-item-checkbox{margin:0 .2em .25em -1.8em;vertical-align:middle}html body .task-list-item-checkbox:hover{cursor:pointer}html body blockquote{margin:16px 0;font-size:inherit;padding:0 15px;color:#5c5c5c;background-color:#f0f0f0;border-left:4px solid #d6d6d6}html body blockquote>:first-child{margin-top:0}html body blockquote>:last-child{margin-bottom:0}html body hr{height:4px;margin:32px 0;background-color:#d6d6d6;border:0 none}html body table{margin:10px 0 15px 0;border-collapse:collapse;border-spacing:0;display:block;width:100%;overflow:auto;word-break:normal;word-break:keep-all}html body table th{font-weight:bold;color:#000}html body table td,html body table th{border:1px solid #d6d6d6;padding:6px 13px}html body dl{padding:0}html body dl dt{padding:0;margin-top:16px;font-size:1em;font-style:italic;font-weight:bold}html body dl dd{padding:0 16px;margin-bottom:16px}html body code{font-family:Menlo,Monaco,Consolas,'Courier New',monospace;font-size:.85em !important;color:#000;background-color:#f0f0f0;border-radius:3px;padding:.2em 0}html body code::before,html body code::after{letter-spacing:-0.2em;content:"\00a0"}html body pre>code{padding:0;margin:0;font-size:.85em !important;word-break:normal;white-space:pre;background:transparent;border:0}html body .highlight{margin-bottom:16px}html body .highlight pre,html body pre{padding:1em;overflow:auto;font-size:.85em !important;line-height:1.45;border:#d6d6d6;border-radius:3px}html body .highlight pre{margin-bottom:0;word-break:normal}html body pre code,html body pre tt{display:inline;max-width:initial;padding:0;margin:0;overflow:initial;line-height:inherit;word-wrap:normal;background-color:transparent;border:0}html body pre code:before,html body pre tt:before,html body pre code:after,html body pre tt:after{content:normal}html body p,html body blockquote,html body ul,html body ol,html body dl,html body pre{margin-top:0;margin-bottom:16px}html body kbd{color:#000;border:1px solid #d6d6d6;border-bottom:2px solid #c7c7c7;padding:2px 4px;background-color:#f0f0f0;border-radius:3px}@media print{html body{background-color:#fff}html body h1,html body h2,html body h3,html body h4,html body h5,html body h6{color:#000;page-break-after:avoid}html body blockquote{color:#5c5c5c}html body pre{page-break-inside:avoid}html body table{display:table}html body img{display:block;max-width:100%;max-height:100%}html body pre,html body code{word-wrap:break-word;white-space:pre}}.markdown-preview{width:100%;height:100%;box-sizing:border-box}.markdown-preview .pagebreak,.markdown-preview .newpage{page-break-before:always}.markdown-preview pre.line-numbers{position:relative;padding-left:3.8em;counter-reset:linenumber}.markdown-preview pre.line-numbers>code{position:relative}.markdown-preview pre.line-numbers .line-numbers-rows{position:absolute;pointer-events:none;top:1em;font-size:100%;left:0;width:3em;letter-spacing:-1px;border-right:1px solid #999;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.markdown-preview pre.line-numbers .line-numbers-rows>span{pointer-events:none;display:block;counter-increment:linenumber}.markdown-preview pre.line-numbers .line-numbers-rows>span:before{content:counter(linenumber);color:#999;display:block;padding-right:.8em;text-align:right}.markdown-preview .mathjax-exps .MathJax_Display{text-align:center !important}.markdown-preview:not([for="preview"]) .code-chunk .btn-group{display:none}.markdown-preview:not([for="preview"]) .code-chunk .status{display:none}.markdown-preview:not([for="preview"]) .code-chunk .output-div{margin-bottom:16px}.scrollbar-style::-webkit-scrollbar{width:8px}.scrollbar-style::-webkit-scrollbar-track{border-radius:10px;background-color:transparent}.scrollbar-style::-webkit-scrollbar-thumb{border-radius:5px;background-color:rgba(150,150,150,0.66);border:4px solid rgba(150,150,150,0.66);background-clip:content-box}html body[for="html-export"]:not([data-presentation-mode]){position:relative;width:100%;height:100%;top:0;left:0;margin:0;padding:0;overflow:auto}html body[for="html-export"]:not([data-presentation-mode]) .markdown-preview{position:relative;top:0}@media screen and (min-width:914px){html body[for="html-export"]:not([data-presentation-mode]) .markdown-preview{padding:2em calc(50% - 457px + 2em)}}@media screen and (max-width:914px){html body[for="html-export"]:not([data-presentation-mode]) .markdown-preview{padding:2em}}@media screen and (max-width:450px){html body[for="html-export"]:not([data-presentation-mode]) .markdown-preview{font-size:14px !important;padding:1em}}@media print{html body[for="html-export"]:not([data-presentation-mode]) #sidebar-toc-btn{display:none}}html body[for="html-export"]:not([data-presentation-mode]) #sidebar-toc-btn{position:fixed;bottom:8px;left:8px;font-size:28px;cursor:pointer;color:inherit;z-index:99;width:32px;text-align:center;opacity:.4}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] #sidebar-toc-btn{opacity:1}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc{position:fixed;top:0;left:0;width:300px;height:100%;padding:32px 0 48px 0;font-size:14px;box-shadow:0 0 4px rgba(150,150,150,0.33);box-sizing:border-box;overflow:auto;background-color:inherit}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar{width:8px}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar-track{border-radius:10px;background-color:transparent}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar-thumb{border-radius:5px;background-color:rgba(150,150,150,0.66);border:4px solid rgba(150,150,150,0.66);background-clip:content-box}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc a{text-decoration:none}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc ul{padding:0 1.6em;margin-top:.8em}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc li{margin-bottom:.8em}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc ul{list-style-type:none}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{left:300px;width:calc(100% -  300px);padding:2em calc(50% - 457px -  150px);margin:0;box-sizing:border-box}@media screen and (max-width:1274px){html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{padding:2em}}@media screen and (max-width:450px){html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{width:100%}}html body[for="html-export"]:not([data-presentation-mode]):not([html-show-sidebar-toc]) .markdown-preview{left:50%;transform:translateX(-50%)}html body[for="html-export"]:not([data-presentation-mode]):not([html-show-sidebar-toc]) .md-sidebar-toc{display:none}/* Please visit the URL below for more information: *//*   https://shd101wyy.github.io/markdown-preview-enhanced/#/customize-css */      </style>    </head>    <body for="html-export">      <div class="mume markdown-preview  ">      <h4 class="mume-header" id="%E8%BF%9B%E5%85%A5%E5%88%9D%E5%A7%8B%E9%A1%B5%E9%9D%A2%E7%82%B9%E5%87%BB">&#x8FDB;&#x5165;&#x521D;&#x59CB;&#x9875;&#x9762;&#x70B9;&#x51FB;</h4><p><img src="source%5Cimg%5Cmd%5Cjava%5Cmaven.png" alt="&#x8FD9;&#x662F;&#x56FE;&#x7247;" title="&#x56FE;&#x7247;"></p>      </div>                                                  </body></html>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/02/20/hello-world/"/>
    <url>/2023/02/20/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your veryfirst post. Check <a href="https://hexo.io/docs/">documentation</a> formore info. If you get any problems when using Hexo, you can find theanswer in <ahref="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> oryou can ask me on <ahref="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start">Quick Start</h2><h3 id="create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>135. 分发糖果</title>
    <link href="/2023/01/11/135-%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C/"/>
    <url>/2023/01/11/135-%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C/</url>
    
    <content type="html"><![CDATA[<h2 id="分发糖果-链接">135. 分发糖果-<ahref="https://leetcode.cn/problems/candy/">链接🚀</a></h2><h3 id="题目">题目</h3><p>n 个孩子站成一排。给你一个整数数组 ratings 表示每个孩子的评分。</p><p>你需要按照以下要求，给这些孩子分发糖果：</p><p>每个孩子至少分配到 1 个糖果。相邻两个孩子评分更高的孩子会获得更多的糖果。请你给每个孩子分发糖果，计算并返回需要准备的 最少糖果数目 。</p><figure><img src="../img/md/leetcode/135.png" alt="135" /><figcaption aria-hidden="true">135</figcaption></figure><h3 id="题解">题解</h3><p>见注释</p><h3 id="代码">代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">candy</span><span class="hljs-params">(<span class="hljs-type">int</span>[] ratings)</span> &#123;<br>        <span class="hljs-type">int</span>[] candyArray = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[ratings.length]; <span class="hljs-comment">//初始化一个糖果数组</span><br>        candyArray[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//从前往后遍历</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> ; i &lt; ratings.length ; i++) &#123;<br>            candyArray[i] = (ratings[i] &gt; ratings[i-<span class="hljs-number">1</span>]) ? candyArray[i-<span class="hljs-number">1</span>] +<span class="hljs-number">1</span> :<span class="hljs-number">1</span>; <br><br>        &#125;<br>        <span class="hljs-comment">//从后往前遍历，candyArray[i] 记录了之前的比较结果</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> ratings.length -<span class="hljs-number">2</span> ; i &gt;= <span class="hljs-number">0</span> ; i--) &#123;<br>            <span class="hljs-keyword">if</span> (ratings[i] &gt; ratings[i+<span class="hljs-number">1</span>]) &#123;<br>                candyArray[i] = Math.max(candyArray[i] , candyArray[i+<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>); <span class="hljs-comment">//candyArray[i]记录了之前的比较结果</span><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; candyArray.length ; i++) &#123;<br>            result += candyArray[i];<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>贪心法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>134. 加油站</title>
    <link href="/2023/01/11/134-%E5%8A%A0%E6%B2%B9%E7%AB%99/"/>
    <url>/2023/01/11/134-%E5%8A%A0%E6%B2%B9%E7%AB%99/</url>
    
    <content type="html"><![CDATA[<h2 id="加油站-链接">134. 加油站-<ahref="https://leetcode.cn/problems/gas-station/">链接🚀</a></h2><h3 id="题目">题目</h3><figure><img src="../img/md/leetcode/134.png" alt="134" /><figcaption aria-hidden="true">134</figcaption></figure><h3 id="题解">题解</h3><p>见注释</p><h3 id="代码">代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">canCompleteCircuit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] gas, <span class="hljs-type">int</span>[] cost)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">curSum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; <span class="hljs-comment">//用于记录当前记录的油量和耗油量的差值</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        <span class="hljs-comment">//从前往后遍历</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; gas.length ; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">rest</span> <span class="hljs-operator">=</span> gas[i] - cost[i]; <span class="hljs-comment">//剩余油量</span><br>            curSum += rest; <span class="hljs-comment">//累加剩余油量</span><br>            <span class="hljs-comment">//记录是否出现小于0的数</span><br>            <span class="hljs-keyword">if</span> (curSum &lt; min) &#123; <span class="hljs-comment">//记录最小的那个负数</span><br>                min = curSum;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//情况一：全局来看 剩余汽油的累加值为负数时，肯定不能跑完一周</span><br>        <span class="hljs-keyword">if</span> (curSum &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">//情况二：如果记录中，出现了负数，则肯定不能到达的,若大于等于0 则满足</span><br>        <span class="hljs-keyword">if</span> (min &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-comment">//情况三：从后往前遍历 将min这个负数给加到大于等于0时 此时返回数组的下标即可</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> gas.length - <span class="hljs-number">1</span> ; i &gt;= <span class="hljs-number">0</span> ; i--) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">rest</span> <span class="hljs-operator">=</span> gas[i] - cost[i];<br>            min += rest;<br>            <span class="hljs-keyword">if</span> (min &gt;= <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span> i; <span class="hljs-comment">//返回数组下标</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>贪心法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>1005. K 次取反后最大化的数组和</title>
    <link href="/2023/01/10/1005-K-%E6%AC%A1%E5%8F%96%E5%8F%8D%E5%90%8E%E6%9C%80%E5%A4%A7%E5%8C%96%E7%9A%84%E6%95%B0%E7%BB%84%E5%92%8C/"/>
    <url>/2023/01/10/1005-K-%E6%AC%A1%E5%8F%96%E5%8F%8D%E5%90%8E%E6%9C%80%E5%A4%A7%E5%8C%96%E7%9A%84%E6%95%B0%E7%BB%84%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h2 id="k-次取反后最大化的数组和-链接">1005. K 次取反后最大化的数组和-<ahref="https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/">链接🚀</a></h2><h3 id="题目">题目</h3><p>给你一个整数数组 nums 和一个整数 k ，按以下方法修改该数组：</p><p>选择某个下标 i 并将 nums[i] 替换为 -nums[i] 。 重复这个过程恰好 k次。可以多次选择同一个下标 i 。</p><p>以这种方式修改数组后，返回数组 可能的最大和 。</p><figure><img src="../img/md/leetcode/1005.png" alt="1005" /><figcaption aria-hidden="true">1005</figcaption></figure><h3 id="题解">题解</h3><p>贪心法：局部最优数组中使最小的负数取反，最小的正数取反；局部最优，从而达到全局最优</p><h3 id="代码">代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">largestSumAfterKNegations</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br><br>        <span class="hljs-comment">//按照绝对值排序（https://blog.csdn.net/qq_41877420/article/details/124503645）</span><br>        nums = IntStream.of(nums)<br>     .boxed()<br>     .sorted((o1, o2) -&gt; Math.abs(o2) - Math.abs(o1))<br>     .mapToInt(Integer::intValue).toArray();<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; length ; i++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] &lt; <span class="hljs-number">0</span> &amp;&amp; k &gt; <span class="hljs-number">0</span>) &#123;<br>                nums[i] = -nums[i];<br>                k--;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (k % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>            nums[length - <span class="hljs-number">1</span>] = -nums[length -<span class="hljs-number">1</span>]; <span class="hljs-comment">//k若还大于0，则继续将数值较小的值</span><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> Arrays.stream(nums).sum();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>贪心法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>45. 跳跃游戏 II</title>
    <link href="/2023/01/09/45-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F-II/"/>
    <url>/2023/01/09/45-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F-II/</url>
    
    <content type="html"><![CDATA[<h2 id="跳跃游戏-ii-链接">45. 跳跃游戏 II-<ahref="https://leetcode.cn/problems/jump-game-ii/">链接🚀</a></h2><h3 id="题目">题目</h3><p>给定一个长度为 n 的 0 索引整数数组 nums。初始位置为 nums[0]。</p><p>每个元素 nums[i] 表示从索引 i 向前跳转的最大长度。换句话说，如果你在nums[i] 处，你可以跳转到任意 nums[i + j] 处:</p><ul><li>0 &lt;= j &lt;= nums[i] </li><li>i + j &lt; n 返回到达 nums[n - 1]的最小跳跃次数。生成的测试用例可以到达 nums[n - 1]。</li></ul><figure><img src="../img/md/leetcode/45.png" alt="45" /><figcaption aria-hidden="true">45</figcaption></figure><h3 id="题解">题解</h3><p>详细思路见代码注释</p><h3 id="代码">代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">jump</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">curDistance</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">//标记覆盖的最大范围</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; <span class="hljs-comment">//记录结果</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">nextDistance</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">//标记覆盖的下一次范围</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; nums.length ; i++) &#123;<br>            nextDistance = Math.max(nums[i] + i , nextDistance);<br>            <br>            <span class="hljs-keyword">if</span> (nextDistance &gt;= nums.length - <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">//当下一次的覆盖范围超过数组的长度时 结果自加1；</span><br>                result++;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (i == curDistance) &#123; <span class="hljs-comment">//当遍历的i等于当前范围时 步数加1，并更新最远范围；</span><br>             <br>                result++;<br>                curDistance = nextDistance; <span class="hljs-comment">//更新最远范围</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>贪心法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>55. 跳跃游戏</title>
    <link href="/2023/01/09/55-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/"/>
    <url>/2023/01/09/55-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="链接">[链接🚀]</h2><h3 id="跳跃游戏-题目httpsleetcode.cnproblemsjump-game">55.跳跃游戏-题目(https://leetcode.cn/problems/jump-game/)</h3><p>给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>判断你是否能够到达最后一个下标。</p><figure><img src="../img/md/leetcode/55.png" alt="55" /><figcaption aria-hidden="true">55</figcaption></figure><h3 id="题解">题解</h3><h3 id="代码">代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canJump</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cover</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">//覆盖范围</span><br><br>        <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">//边界条件</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt;= cover ; i++) &#123;<br>            cover = Math.max(i + nums[i] , cover); <span class="hljs-comment">// 关键，当前i和所在的值相加的值 需要和cover比较，记录下最大的值 ，然后依次比较；</span><br>            <span class="hljs-keyword">if</span> (cover &gt;= nums.length - <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>贪心法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>122. 买卖股票的最佳时机 II</title>
    <link href="/2023/01/09/122-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-II/"/>
    <url>/2023/01/09/122-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-II/</url>
    
    <content type="html"><![CDATA[<h2 id="买卖股票的最佳时机-ii-链接">122. 买卖股票的最佳时机 II-<ahref="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">链接🚀</a></h2><h3 id="题目">题目</h3><figure><img src="../img/md/leetcode/122.png" alt="122" /><figcaption aria-hidden="true">122</figcaption></figure><h3 id="题解">题解</h3><p>贪心法：只需要收集每连续两天的差值，若收益为正，则累加，若收益为负则加0，具体代码实现通过max函数实现</p><h3 id="代码">代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] prices)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> ; i &lt; prices.length ; i++) &#123;<br>            result += Math.max(prices[i] - prices[i - <span class="hljs-number">1</span>] , <span class="hljs-number">0</span>); <span class="hljs-comment">//只需收集正收益，若收益为负，则加0；</span><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>贪心法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>53. 最大子数组和</title>
    <link href="/2023/01/08/53-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C/"/>
    <url>/2023/01/08/53-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h2 id="链接">[链接🚀]</h2><h3 id="题目">题目</h3><p>给你一个整数数组 nums，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p>子数组 是数组中的一个连续部分。</p><figure><img src="../img/md/leetcode/53.png" alt="53" /><figcaption aria-hidden="true">53</figcaption></figure><h3 id="题解">题解</h3><p>遍历并累加数组中的值，若遍历时的累加值大于存放的结果，则将临时值存放到结果；若count值小于0，则将count重置为0；</p><h3 id="代码">代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxSubArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE; <span class="hljs-comment">//存放结果</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; nums.length ; i++) &#123;<br><br>            count += nums[i]; <span class="hljs-comment">//累加</span><br>        <br>            <span class="hljs-keyword">if</span> (count &gt; result) &#123;<br>                result = count;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (count &lt;= <span class="hljs-number">0</span>) &#123;<br>                count = <span class="hljs-number">0</span>;<br>            &#125;<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>贪心法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>376. 摆动序列</title>
    <link href="/2023/01/08/376-%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97/"/>
    <url>/2023/01/08/376-%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h2 id="摆动序列-链接">376. 摆动序列-<ahref="https://leetcode.cn/problems/wiggle-subsequence/">链接🚀</a></h2><h3 id="题目">题目</h3><p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。</p><p>例如， [1, 7, 4, 9, 2, 5] 是一个 摆动序列 ，因为差值 (6, -3, 5, -7,3) 是正负交替出现的。</p><p>相反，[1, 4, 7, 2, 5] 和 [1, 7, 4, 5, 5]不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。子序列可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。</p><p>给你一个整数数组 nums ，返回 nums 中作为 摆动序列 的 最长子序列的长度。</p><figure><img src="../img/md/leetcode/376.png" alt="376" /><figcaption aria-hidden="true">376</figcaption></figure><h3 id="题解">题解</h3><p>在遍历时 ，判断当前差值为负值时，之前差值必为正值，当前差值为正值时，之前差值必为负值；</p><h3 id="代码">代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">wiggleMaxLength</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-comment">//当只有一个值时，默认只有一个值，直接返回</span><br><br>        <span class="hljs-keyword">if</span> (nums.length &lt;= <span class="hljs-number">1</span> ) &#123;<br>            <span class="hljs-keyword">return</span> nums.length;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">cur_Difference</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ;<span class="hljs-comment">// 定义当前的差值</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">pre_Difference</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ;<span class="hljs-comment">// 定义之前的差值</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; <span class="hljs-comment">//定义结果默认为1；</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; nums.length - <span class="hljs-number">1</span> ; i++) &#123;<br>            cur_Difference = nums[i+<span class="hljs-number">1</span>] - nums[i] ; <span class="hljs-comment">//获取当前值</span><br>            <span class="hljs-comment">//成立条件 ，满足该条件则结果值自增1；</span><br>            <span class="hljs-keyword">if</span> (cur_Difference &lt; <span class="hljs-number">0</span> &amp;&amp; pre_Difference &gt;= <span class="hljs-number">0</span> || cur_Difference &gt; <span class="hljs-number">0</span> &amp;&amp; pre_Difference &lt;= <span class="hljs-number">0</span>) &#123;<br>                result++;<br>                pre_Difference = cur_Difference;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>贪心法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>455. 分发饼干</title>
    <link href="/2023/01/08/455-%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2/"/>
    <url>/2023/01/08/455-%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2/</url>
    
    <content type="html"><![CDATA[<h2 id="分发饼干-链接">455. 分发饼干-<ahref="https://leetcode.cn/problems/assign-cookies/">链接🚀</a></h2><h3 id="题目">题目</h3><p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。</p><p>对每个孩子i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干j，都有一个尺寸 s[j] 。如果 s[j] &gt;= g[i]，我们可以将这个饼干 j分配给孩子 i，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p><figure><img src="../img/md/leetcode/455.png" alt="455" /><figcaption aria-hidden="true">455</figcaption></figure><h3 id="题解">题解</h3><p>贪心法：</p><p>先将两个数组排序，再从后往前遍历，若当前饼干能满足孩子的胃口则饼干的index--；</p><p>局部选择最大的饼干满足胃口大的孩子；</p><p>代码如下：</p><h3 id="代码">代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findContentChildren</span><span class="hljs-params">(<span class="hljs-type">int</span>[] g, <span class="hljs-type">int</span>[] s)</span> &#123;<br><br>        Arrays.sort(g); <span class="hljs-comment">// g排序 小孩</span><br><br>        Arrays.sort(s); <span class="hljs-comment">// s排序 饼干</span><br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> s.length - <span class="hljs-number">1</span>; <span class="hljs-comment">//饼干数量</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">//记录最终结果</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> g.length - <span class="hljs-number">1</span> ; i &gt;= <span class="hljs-number">0</span> ; i--) &#123;<br>            <span class="hljs-keyword">if</span> (index &gt;= <span class="hljs-number">0</span> &amp;&amp; s[index] &gt;= g[i]) &#123;<br><br>                result++;<br>                index--;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>贪心法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>51. N 皇后</title>
    <link href="/2022/12/28/51-N-%E7%9A%87%E5%90%8E/"/>
    <url>/2022/12/28/51-N-%E7%9A%87%E5%90%8E/</url>
    
    <content type="html"><![CDATA[<h2 id="n-皇后-链接">51. N 皇后-<ahref="https://leetcode.cn/problems/n-queens/">链接🚀</a></h2><h3 id="题目">题目</h3><p>按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。</p><p>n 皇后问题 研究的是如何将 n 个皇后放置在 n×n的棋盘上，并且使皇后彼此之间不能相互攻击。</p><p>给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。</p><p>每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 'Q' 和'.' 分别代表了皇后和空位。</p><figure><img src="../img/md/leetcode/51.png" alt="51" /><figcaption aria-hidden="true">51</figcaption></figure><h3 id="题解">题解</h3><h3 id="代码">代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    List&lt;List&lt;String&gt;&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="hljs-title function_">solveNQueens</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">char</span>[][] chessboard = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[n][n];<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span>[] c : chessboard) &#123;<br>            Arrays.fill(c , <span class="hljs-string">&#x27;.&#x27;</span>);<br>        &#125;<br><br>        solveNQueensHelper(n , <span class="hljs-number">0</span> , chessboard);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValide</span><span class="hljs-params">(<span class="hljs-type">int</span> n , <span class="hljs-type">int</span> row , <span class="hljs-type">int</span> col , <span class="hljs-type">char</span>[][] chessboard )</span> &#123;<br>        <span class="hljs-comment">// cheack column</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; row ; ++i) &#123;<br>            <span class="hljs-keyword">if</span>(chessboard[i][col] == <span class="hljs-string">&#x27;Q&#x27;</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//cheack 45</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> row - <span class="hljs-number">1</span> , j = col - <span class="hljs-number">1</span> ; i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span>  ; i-- , j--) &#123;<br>            <span class="hljs-keyword">if</span> (chessboard[i][j] == <span class="hljs-string">&#x27;Q&#x27;</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br><br><br>        <span class="hljs-comment">//check 135</span><br>        <span class="hljs-keyword">for</span> ( <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> row - <span class="hljs-number">1</span> , j = col + <span class="hljs-number">1</span> ; i&gt;=<span class="hljs-number">0</span> &amp;&amp; j &lt;= n - <span class="hljs-number">1</span> ; i-- , j++) &#123;<br>            <span class="hljs-keyword">if</span> (chessboard[i][j] == <span class="hljs-string">&#x27;Q&#x27;</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">solveNQueensHelper</span><span class="hljs-params">(<span class="hljs-type">int</span> n , <span class="hljs-type">int</span> row , <span class="hljs-type">char</span>[][] chessboard)</span> &#123;<br>        <span class="hljs-comment">//终止条件</span><br>        <span class="hljs-keyword">if</span> (n == row) &#123;<br>            result.add(Array1(chessboard));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">col</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; col &lt; n ; ++col) &#123;<br>            <span class="hljs-keyword">if</span> (isValide(n , row , col , chessboard)) &#123;<br>                chessboard[row][col] = <span class="hljs-string">&#x27;Q&#x27;</span>;<br>                solveNQueensHelper(n , row+<span class="hljs-number">1</span>, chessboard);<br>                chessboard[row][col] = <span class="hljs-string">&#x27;.&#x27;</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//单次结果集</span><br>    <span class="hljs-keyword">public</span> List <span class="hljs-title function_">Array1</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] chessboard)</span> &#123;<br>        List&lt;String&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span>[] c : chessboard) &#123;<br>            path.add(String.copyValueOf(c));<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> path;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>回溯</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>47. 全排列 II</title>
    <link href="/2022/12/26/47-%E5%85%A8%E6%8E%92%E5%88%97-II/"/>
    <url>/2022/12/26/47-%E5%85%A8%E6%8E%92%E5%88%97-II/</url>
    
    <content type="html"><![CDATA[<h2 id="全排列-ii链接">47. 全排列 II<ahref="https://leetcode.cn/problems/permutations-ii/">链接🚀</a></h2><h3 id="题目">题目</h3><p>给定一个可包含重复数字的序列 nums ，按任意顺序返回所有不重复的全排列。</p><figure><img src="../img/md/leetcode/47.png" alt="47" /><figcaption aria-hidden="true">47</figcaption></figure><h3 id="题解">题解</h3><h3 id="代码">代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    List&lt;List&lt;Integer&gt;&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    List&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    <span class="hljs-type">boolean</span>[] used;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">permuteUnique</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        used = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[nums.length];<br>        Arrays.fill(used , <span class="hljs-literal">false</span>);<br>        Arrays.sort(nums);<br>        permuteUniqueHelper(nums , used);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">permuteUniqueHelper</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums ,<span class="hljs-type">boolean</span>[] used )</span> &#123;<br>        <span class="hljs-comment">//终止条件</span><br>        <span class="hljs-keyword">if</span> (path.size() == nums.length) &#123;<br>            result.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//递归&amp;&amp;去重</span><br><br>        <span class="hljs-keyword">for</span> ( <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; nums.length ; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>] &amp;&amp; used[i - <span class="hljs-number">1</span>] == <span class="hljs-literal">false</span>) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (used[i] == <span class="hljs-literal">false</span>) &#123;<br>                used[i] = <span class="hljs-literal">true</span>;<br>                path.add(nums[i]);<br>                permuteUniqueHelper(nums , used);<br>                used[i] = <span class="hljs-literal">false</span>;<br>                path.remove(path.size() - <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>回溯</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>46. 全排列</title>
    <link href="/2022/12/18/46-%E5%85%A8%E6%8E%92%E5%88%97/"/>
    <url>/2022/12/18/46-%E5%85%A8%E6%8E%92%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h2 id="全排列-链接">46. 全排列-<ahref="https://leetcode.cn/problems/permutations/">链接🚀</a></h2><h3 id="题目">题目</h3><p>给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以按任意顺序 返回答案。</p><figure><img src="../img/md/leetcode/46.png" alt="46" /><figcaption aria-hidden="true">46</figcaption></figure><h3 id="题解">题解</h3><h3 id="代码">代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    <span class="hljs-keyword">private</span> List&lt;List&lt;Integer&gt;&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">private</span> List&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-type">boolean</span>[] used;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">permute</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        used = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[nums.length];<br>        Arrays.fill(used , <span class="hljs-literal">false</span>);<br>        permuteHelper(nums , used);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">permuteHelper</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums , <span class="hljs-type">boolean</span>[] used)</span> &#123;<br>        <br>        <span class="hljs-comment">//终止条件</span><br>        <span class="hljs-keyword">if</span> (path.size() == nums.length) &#123;<br>            result.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> ( <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; nums.length ; i++)&#123;<br>            <span class="hljs-comment">//去重操作</span><br>            <span class="hljs-keyword">if</span> ( used[i] == <span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            used[i] = <span class="hljs-literal">true</span>;<br>            path.add(nums[i]);<br>            permuteHelper(nums , used);<br>            used[i] = <span class="hljs-literal">false</span>;<br>            path.remove(path.size() - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>回溯</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>491. 递增子序列</title>
    <link href="/2022/12/18/491-%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <url>/2022/12/18/491-%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h2 id="递增子序列-链接">491. 递增子序列-<ahref="https://leetcode.cn/problems/increasing-subsequences/">链接🚀</a></h2><h3 id="题目">题目</h3><p>给你一个整数数组 nums，找出并返回所有该数组中不同的递增子序列，递增子序列中 至少有两个元素。你可以按 任意顺序 返回答案。</p><p>数组中可能含有重复元素，如出现两个整数相等，也可以视作递增序列的一种特殊情况。</p><figure><img src="../img/md/leetcode/491.png" alt="491" /><figcaption aria-hidden="true">491</figcaption></figure><h3 id="题解">题解</h3><h3 id="代码">代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    <span class="hljs-keyword">private</span> List&lt;List&lt;Integer&gt;&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(); <span class="hljs-comment">//收集结果</span><br>    <span class="hljs-keyword">private</span> List&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(); <span class="hljs-comment">//路径上的值</span><br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">findSubsequences</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        findSubsequencesHelper(nums , <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">findSubsequencesHelper</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums , <span class="hljs-type">int</span> searchIndex)</span> &#123;<br>        <span class="hljs-comment">//终止条件</span><br>        <span class="hljs-keyword">if</span> (path.size() &gt; <span class="hljs-number">1</span>) &#123;<br>            result.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(path));<br>        &#125;<br><br>        <span class="hljs-type">int</span>[] used = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">201</span>]; <span class="hljs-comment">//每层都会初始化</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> searchIndex ; i &lt; nums.length ; i++) &#123;<br>            <span class="hljs-keyword">if</span> ((!path.isEmpty() &amp;&amp; nums[i] &lt; path.get(path.size() - <span class="hljs-number">1</span>)) || used[nums[i] + <span class="hljs-number">100</span>] == <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            used[nums[i] + <span class="hljs-number">100</span>]  = <span class="hljs-number">1</span>;     <br>            path.add(nums[i]);<br>            findSubsequencesHelper(nums , i + <span class="hljs-number">1</span>);<br>            path.remove(path.size() - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>回溯</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>90. 子集 II</title>
    <link href="/2022/12/15/90-%E5%AD%90%E9%9B%86-II/"/>
    <url>/2022/12/15/90-%E5%AD%90%E9%9B%86-II/</url>
    
    <content type="html"><![CDATA[<h2 id="子集-ii-链接">90. 子集 II-<ahref="https://leetcode.cn/problems/subsets-ii/">链接🚀</a></h2><h3 id="题目">题目</h3><p>给你一个整数数组 nums，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。</p><p>解集 不能 包含重复的子集。返回的解集中，子集可以按 任意顺序排列。</p><figure><img src="../img/md/leetcode/90.png" alt="90" /><figcaption aria-hidden="true">90</figcaption></figure><h3 id="题解">题解</h3><h3 id="代码">代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//结果集合</span><br>    List&lt;List&lt;Integer&gt;&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-comment">//路径集合</span><br>    LinkedList&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-type">boolean</span>[] used;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">subsetsWithDup</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br><br>        <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">0</span>) &#123;<br>            result.add(path);<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br><br>        Arrays.sort(nums);<br><br>        used = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[nums.length];<br>        subsetsWithDupHelper(nums , <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">subsetsWithDupHelper</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums , <span class="hljs-type">int</span> searchIndex)</span> &#123;<br>        result.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(path));<br>        <span class="hljs-comment">//终止条件</span><br>        <span class="hljs-keyword">if</span> (searchIndex &gt;= nums.length) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> searchIndex ; i &lt; nums.length ; i++) &#123;<br>            <br>            <span class="hljs-comment">//去重操作</span><br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>] &amp;&amp; used[i - <span class="hljs-number">1</span>] == <span class="hljs-literal">false</span>) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            path.add(nums[i]);<br>            used[i] = <span class="hljs-literal">true</span>;<br><br>            subsetsWithDupHelper(nums , i + <span class="hljs-number">1</span>);<br><br>            used[i] = <span class="hljs-literal">false</span>;<br>            path.removeLast();<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>回溯</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>78. 子集</title>
    <link href="/2022/12/15/78-%E5%AD%90%E9%9B%86/"/>
    <url>/2022/12/15/78-%E5%AD%90%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h2 id="子集-链接">78. 子集-<ahref="https://leetcode.cn/problems/subsets/">链接🚀</a></h2><h3 id="题目">题目</h3><p>给你一个整数数组 nums ，数组中的元素 互不相同。返回该数组所有可能的子集（幂集）。</p><p>解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。</p><figure><img src="../img/md/leetcode/78.png" alt="78" /><figcaption aria-hidden="true">78</figcaption></figure><h3 id="题解">题解</h3><h3 id="代码">代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//保存结果集</span><br>    List&lt;List&lt;Integer&gt;&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-comment">// 单层链表</span><br><br>    LinkedList&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">subsets</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        subsetsHelper(nums , <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">subsetsHelper</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums , <span class="hljs-type">int</span> searchIndex)</span> &#123;<br>        result.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(path)); <span class="hljs-comment">// 与组合、分割问题不一样的是 ，子集问题是将路径上的元素进行保存的</span><br>        <span class="hljs-comment">//终止条件</span><br>        <span class="hljs-keyword">if</span> (searchIndex &gt;= nums.length) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> searchIndex ; i &lt; nums.length ; i++) &#123;<br>            path.add(nums[i]);<br>            subsetsHelper(nums , i + <span class="hljs-number">1</span>);<br>            path.removeLast();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>回溯</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>93. 复原 IP 地址</title>
    <link href="/2022/12/15/93-%E5%A4%8D%E5%8E%9F-IP-%E5%9C%B0%E5%9D%80/"/>
    <url>/2022/12/15/93-%E5%A4%8D%E5%8E%9F-IP-%E5%9C%B0%E5%9D%80/</url>
    
    <content type="html"><![CDATA[<h2 id="复原-ip-地址-链接">93. 复原 IP 地址-<ahref="https://leetcode.cn/problems/restore-ip-addresses/">链接🚀</a></h2><h3 id="题目">题目</h3><p>有效 IP 地址 正好由四个整数（每个整数位于 0 到 255之间组成，且不能含有前导 0），整数之间用 '.' 分隔。</p><p>例如："0.1.2.201" 和 "192.168.1.1" 是 有效 IP 地址，但是"0.011.255.245"、"192.168.1.312" 和 "192.168@1.1" 是 无效 IP 地址。给定一个只包含数字的字符串 s ，用以表示一个 IP 地址，返回所有可能的有效IP 地址，这些地址可以通过在 s 中插入 '.' 来形成。你 不能 重新排序或删除s 中的任何数字。你可以按 任何 顺序返回答案。</p><figure><img src="../img/md/leetcode/93.png" alt="93" /><figcaption aria-hidden="true">93</figcaption></figure><h3 id="题解">题解</h3><h3 id="代码">代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//定义一个链表用来保存字符串</span><br>    List&lt;String&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">restoreIpAddresses</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-comment">// 剪枝操作--当字符串的个数总和大于12时，返回空的结果集</span><br>        <span class="hljs-keyword">if</span> (s.length() &gt; <span class="hljs-number">12</span>) &#123;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br><br>        <span class="hljs-comment">// 递归函数</span><br>        restoreIpAddressesHelper(s , <span class="hljs-number">0</span> , <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">restoreIpAddressesHelper</span><span class="hljs-params">(String s , <span class="hljs-type">int</span> searchIndex , <span class="hljs-type">int</span> pointNum)</span> &#123;<br>        <span class="hljs-comment">// 1. 递归终止条件 当pointNum == 3 时 意味着已经切割到最后一段；</span><br>        <span class="hljs-comment">// 此时我们应当判断最后一段的字符是否有效，若有效则将该段字符串放入到结果集中后再返回</span><br>        <span class="hljs-keyword">if</span> (pointNum == <span class="hljs-number">3</span>) &#123;<br>            <span class="hljs-keyword">if</span> (isValid(s , searchIndex , s.length() - <span class="hljs-number">1</span>)) &#123;<br>                result.add(s);<br>            &#125;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//递归和回溯部分</span><br>        <span class="hljs-comment">// 判断子区间字符串是否有效，若有效则在字符后加入点号 ，并将pointNum自加1</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> searchIndex ; i &lt; s.length() ; i++) &#123;<br>            <span class="hljs-keyword">if</span> (isValid(s , searchIndex , i)) &#123;<br>                s = s.substring(<span class="hljs-number">0</span> , i+<span class="hljs-number">1</span>) +<span class="hljs-string">&#x27;.&#x27;</span> + s.substring(i+<span class="hljs-number">1</span>); <span class="hljs-comment">//在字符串后面插入point</span><br>                pointNum++;<br>                restoreIpAddressesHelper(s , i + <span class="hljs-number">2</span> , pointNum);<span class="hljs-comment">//开始递归</span><br>                pointNum--;<br>                s = s.substring(<span class="hljs-number">0</span> , i+<span class="hljs-number">1</span>) + s.substring(i + <span class="hljs-number">2</span>); <span class="hljs-comment">//回溯删除point</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 判断在该区间所组成的数字[start . end]是否合法</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(String s , <span class="hljs-type">int</span> start , <span class="hljs-type">int</span> end)</span> &#123;<br>        <span class="hljs-comment">// 1. 如果越界肯定不对</span><br><br>        <span class="hljs-keyword">if</span> (start &gt; end) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 2. 0开头的数字不合法 注意:字符串取值需要用到chatAt()函数</span><br><br>        <span class="hljs-keyword">if</span> (s.charAt(start) == <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; start != end) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 3. 遇到非数字字符不合法 &amp;&amp; 遇到大于255的数 他也是不合法的</span><br>    <br>        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; <span class="hljs-comment">//定义一个用于记录该段最大值的变量 [start , end] 左闭又闭 </span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start ; i &lt;= end ; i++) &#123;<br>            <span class="hljs-keyword">if</span> (s.charAt(i)&gt; <span class="hljs-string">&#x27;9&#x27;</span> || s.charAt(i) &lt; <span class="hljs-string">&#x27;0&#x27;</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br><br>            num = num * <span class="hljs-number">10</span> + (s.charAt(i) - <span class="hljs-string">&#x27;0&#x27;</span>); <span class="hljs-comment">//判断值是否大于255</span><br>            <span class="hljs-keyword">if</span> (num &gt; <span class="hljs-number">255</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>回溯</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>131. 分割回文串</title>
    <link href="/2022/12/12/131-%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2/"/>
    <url>/2022/12/12/131-%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h2 id="分割回文串-链接">131. 分割回文串-<ahref="https://leetcode.cn/problems/palindrome-partitioning/">链接🚀</a></h2><h3 id="题目">题目</h3><p>给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是 回文串。返回 s 所有可能的分割方案。</p><p>回文串 是正着读和反着读都一样的字符串。</p><h3 id="题解">题解</h3><h3 id="代码">代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    List&lt;List&lt;String&gt;&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    List&lt;String&gt;  path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="hljs-title function_">partition</span><span class="hljs-params">(String s)</span> &#123;<br>        partitionHelper(s , <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">partitionHelper</span><span class="hljs-params">(String s , <span class="hljs-type">int</span> searchIndex)</span> &#123;<br>        <span class="hljs-comment">//终止条件</span><br>        <span class="hljs-keyword">if</span> (searchIndex &gt;= s.length()) &#123;<br>            result.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(path)); <span class="hljs-comment">//将最终的结果加入到结果集当中</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> searchIndex ; i &lt; s.length() ; i++) &#123;<br>            <span class="hljs-keyword">if</span> (isPalindrone(s , searchIndex , i)) &#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> s.substring(searchIndex , i + <span class="hljs-number">1</span>);<br>               <span class="hljs-comment">/*  System.out.println(searchIndex ); 用于测试的代码 此substring 的区间为左闭右开区间</span><br><span class="hljs-comment">                System.out.println(i+ 1 );</span><br><span class="hljs-comment">                System.out.println(str ); */</span><br>                path.add(str); <span class="hljs-comment">// 加入到path中</span><br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            <span class="hljs-comment">/* 确保不会取到重复元素 */</span><br>            partitionHelper(s , i + <span class="hljs-number">1</span>);<br>            path.remove(path.size() - <span class="hljs-number">1</span>); <span class="hljs-comment">// 回溯操作</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/* 判断是否为回文字符串 */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPalindrone</span><span class="hljs-params">(String s , <span class="hljs-type">int</span> start , <span class="hljs-type">int</span> end)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i= start ,j = end ; i &lt; j ; i++ , j--) &#123;<br>            System.out.println(s.charAt(i) != s.charAt(j));<br>            <span class="hljs-keyword">if</span> ( s.charAt(i) != s.charAt(j)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>回溯</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>40. 组合总和 II</title>
    <link href="/2022/12/12/40-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-II/"/>
    <url>/2022/12/12/40-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-II/</url>
    
    <content type="html"><![CDATA[<h2 id="组合总和-ii-链接">40. 组合总和 II-<ahref="https://leetcode.cn/problems/combination-sum-ii/">链接🚀</a></h2><h3 id="题目">题目</h3><p>给定一个候选人编号的集合 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p><p>candidates 中的每个数字在每个组合中只能使用 一次 。</p><p>注意：解集不能包含重复的组合。 </p><figure><img src="../img/md/leetcode/40.png" alt="40" /><figcaption aria-hidden="true">40</figcaption></figure><h3 id="题解">题解</h3><p>看代码注释</p><h3 id="代码">代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    List&lt;List&lt;Integer&gt;&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(); <span class="hljs-comment">// </span><br><br>    List&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-type">boolean</span>[] used;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combinationSum2</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">boolean</span>[] used = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[candidates.length];<br>        Arrays.fill(used , <span class="hljs-literal">false</span>);<br>        Arrays.sort(candidates); <span class="hljs-comment">//先进行排序，否则某些元素在物理上位置不一致</span><br>        combinationSum2Helper(candidates , target , <span class="hljs-number">0</span> , <span class="hljs-number">0</span> , used);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">combinationSum2Helper</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates , <span class="hljs-type">int</span> target , <span class="hljs-type">int</span> sum , <span class="hljs-type">int</span> searchIndex , <span class="hljs-type">boolean</span>[] used)</span> &#123;<br>        <span class="hljs-keyword">if</span> (sum &gt; target) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (sum == target) &#123;<br>            result.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> searchIndex ; i &lt; candidates.length ; i++) &#123;<br><br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; candidates[i] == candidates[i - <span class="hljs-number">1</span>] &amp;&amp; used[i - <span class="hljs-number">1</span>] == <span class="hljs-literal">false</span>) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            path.add(candidates[i]);<br>            sum += candidates[i];<br>            used[i] = <span class="hljs-literal">true</span>;<br>            combinationSum2Helper(candidates , target , sum , i + <span class="hljs-number">1</span> , used);<br>            used[i] = <span class="hljs-literal">false</span>;<br>            sum -= candidates[i];<br>            path.remove(path.size() - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>回溯</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>39. 组合总和</title>
    <link href="/2022/12/12/39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/"/>
    <url>/2022/12/12/39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h2 id="组合总和-链接">39. 组合总和-<ahref="https://leetcode.cn/problems/combination-sum/">链接🚀</a></h2><h3 id="题目">题目</h3><p>给你一个 无重复元素 的整数数组 candidates和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。</p><p>candidates 中的 同一个 数字可以 无限制重复被选取。如果至少一个数字的被选数量不同，则两种组合是不同的。 </p><p>对于给定的输入，保证和为 target 的不同组合数少于 150 个。</p><figure><img src="../img/md/leetcode/39.png" alt="39" /><figcaption aria-hidden="true">39</figcaption></figure><h3 id="题解">题解</h3><p>具体看代码注释</p><h3 id="代码">代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    List&lt;List&lt;Integer&gt;&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    LinkedList&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combinationSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        combinationSumHelper(candidates , target , sum , <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">combinationSumHelper</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target , <span class="hljs-type">int</span> sum , <span class="hljs-type">int</span> searchIndex)</span> &#123;<br>        <span class="hljs-keyword">if</span> (sum &gt; target) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (sum == target) &#123;<br>            result.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> ( <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> searchIndex ; i &lt; candidates.length ; i++) &#123;<br>            path.add(candidates[i]);<br>            sum +=candidates[i];<br>            combinationSumHelper(candidates , target , sum , i); <span class="hljs-comment">//这里是i而不是i + 1,这就是意味着可以重复在candidates里面取元素；</span><br>            sum -= candidates[i];<br>            path.remove(path.size() - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>回溯</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>17. 电话号码的字母组合</title>
    <link href="/2022/12/11/17-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/"/>
    <url>/2022/12/11/17-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/</url>
    
    <content type="html"><![CDATA[<h2 id="电话号码的字母组合-链接">17. 电话号码的字母组合-<ahref="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">链接🚀</a></h2><h3 id="题目">题目</h3><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按任意顺序 返回。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意 1不对应任何字母。</p><figure><img src="../img/md/leetcode/17.png" alt="17" /><figcaption aria-hidden="true">17</figcaption></figure><h3 id="题解">题解</h3><p>把回溯法与树的结构相结合，可以很快的就得到理解</p><h3 id="代码">代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>     List&lt;String&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>     <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">letterCombinations</span><span class="hljs-params">(String digits)</span> &#123;<br>        <span class="hljs-keyword">if</span> (digits == <span class="hljs-literal">null</span> || digits.length() == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br><br>        String[] string = &#123;<span class="hljs-string">&quot;&quot;</span> , <span class="hljs-string">&quot;&quot;</span> ,<span class="hljs-string">&quot;abc&quot;</span> , <span class="hljs-string">&quot;def&quot;</span> , <span class="hljs-string">&quot;ghi&quot;</span> , <span class="hljs-string">&quot;jkl&quot;</span> , <span class="hljs-string">&quot;mno&quot;</span>, <span class="hljs-string">&quot;pqrs&quot;</span> , <span class="hljs-string">&quot;tuv&quot;</span> , <span class="hljs-string">&quot;wxyz&quot;</span>&#125;;<br>        letterCombinationsHelper(digits , <span class="hljs-number">0</span> , string);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">letterCombinationsHelper</span><span class="hljs-params">(String digits , <span class="hljs-type">int</span> index , String[] string)</span> &#123;<br>        <span class="hljs-comment">//终止条件</span><br>        <span class="hljs-keyword">if</span> (index == digits.length()) &#123;<br>            result.add(temp.toString());<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//获取当前数字所对应的字符串</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> string[digits.charAt(index) - <span class="hljs-string">&#x27;0&#x27;</span>]; <br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ;i &lt; str.length() ; i++) &#123;<br>            temp.append(str.charAt(i));<br>            letterCombinationsHelper(digits , index + <span class="hljs-number">1</span> , string);<br>            temp.deleteCharAt(temp.length() - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/* </span><br><span class="hljs-comment"> for (int i = 0; i &lt; str.length(); i++) &#123;</span><br><span class="hljs-comment">            temp.append(str.charAt(i));</span><br><span class="hljs-comment">            //c</span><br><span class="hljs-comment">            backTracking(digits, numString, num + 1);</span><br><span class="hljs-comment">            //剔除末尾的继续尝试</span><br><span class="hljs-comment">            temp.deleteCharAt(temp.length() - 1);</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>回溯</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>216. 组合总和 III</title>
    <link href="/2022/12/11/216-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-III/"/>
    <url>/2022/12/11/216-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-III/</url>
    
    <content type="html"><![CDATA[<h2 id="组合总和-iii-链接">216. 组合总和 III-<ahref="https://leetcode.cn/problems/combination-sum-iii/">链接🚀</a></h2><h3 id="题目">题目</h3><p>找出所有相加之和为 n 的 k 个数的组合，且满足下列条件：</p><p>只使用数字1到9 每个数字 最多使用一次  返回 所有可能的有效组合的列表。该列表不能包含相同的组合两次，组合可以以任何顺序返回。</p><h3 id="题解">题解</h3><p>只需要终止条件判断的时候判断累加的和是否等于目标值，若等于，则将该paths添加到结果集中，若不等于则继续遍历；</p><p>本题有个巧妙地点，在于，我们将sum逐层累加地方式将值传入；最后还进行了回溯</p><h3 id="代码">代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    List&lt;List&lt;Integer&gt;&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    LinkedList&lt;Integer&gt; paths = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combinationSum3</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n)</span> &#123;<br>        combinationSum3Helper(k , n , <span class="hljs-number">1</span> , <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">combinationSum3Helper</span><span class="hljs-params">(<span class="hljs-type">int</span> k , <span class="hljs-type">int</span> n , <span class="hljs-type">int</span> searchIndex , <span class="hljs-type">int</span> sum)</span> &#123;<br>        <br>        <span class="hljs-keyword">if</span> (sum &gt; n) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span> (paths.size() == k) &#123;<br><br>            <span class="hljs-keyword">if</span> (sum == n) &#123;<br>                result.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(paths));<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> searchIndex ; i &lt;= <span class="hljs-number">9</span> - (k - paths.size()) + <span class="hljs-number">1</span>; i++) &#123;<br>            paths.add(i);<br>            sum += i;<br>            combinationSum3Helper(k, n , i + <span class="hljs-number">1</span> , sum);<br>            paths.removeLast();<br>            sum -= i;<br>        &#125;<br><br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>回溯</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>77. 组合</title>
    <link href="/2022/12/10/77-%E7%BB%84%E5%90%88/"/>
    <url>/2022/12/10/77-%E7%BB%84%E5%90%88/</url>
    
    <content type="html"><![CDATA[<h2 id="组合-链接">77. 组合-<ahref="https://leetcode.cn/problems/combinations/">链接🚀</a></h2><h3 id="题目">题目</h3><p>给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。</p><p>你可以按 任何顺序 返回答案。</p><h3 id="题解">题解</h3><h3 id="代码">代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    List&lt;List&lt;Integer&gt;&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    LinkedList&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(); <span class="hljs-comment">// 定义两个全局变量，一个用于收集最终结果，一个用户收集中间结果</span><br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combine</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)</span> &#123;<br>        combineHelper(n , k , <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">combineHelper</span><span class="hljs-params">(<span class="hljs-type">int</span> n , <span class="hljs-type">int</span> k , <span class="hljs-type">int</span> searchIndex)</span> &#123;<br>        <span class="hljs-comment">/* 终止条件 */</span><br>        <span class="hljs-keyword">if</span> (path.size() == k) &#123;<br>            result.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> searchIndex ; i &lt;= n - (k - path.size()) + <span class="hljs-number">1</span>; i++) &#123;<br>            path.add(i);<br>            combineHelper(n , k , i + <span class="hljs-number">1</span>); <span class="hljs-comment">//找完集合中的第一个元素后 还要找余下的元素</span><br>            path.removeLast();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>538. 把二叉搜索树转换为累加树</title>
    <link href="/2022/12/08/538-%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91/"/>
    <url>/2022/12/08/538-%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h2 id="把二叉搜索树转换为累加树-链接">538. 把二叉搜索树转换为累加树-<ahref="https://leetcode.cn/problems/convert-bst-to-greater-tree/">链接🚀</a></h2><h3 id="题目">题目</h3><p>给出二叉 搜索树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater SumTree），使每个节点node 的新值等于原树中大于或等于 node.val 的值之和。</p><p>提醒一下，二叉搜索树满足下列约束条件：</p><p>节点的左子树仅包含键 小于 节点键的节点。 节点的右子树仅包含键 大于节点键的节点。 左右子树也必须是二叉搜索树。</p><figure><img src="/img/md/leetcode/538.png" alt="538" /><figcaption aria-hidden="true">538</figcaption></figure><h3 id="题解">题解</h3><h3 id="代码">代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> pre ;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">convertBST</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        pre = <span class="hljs-number">0</span>;<br>        traverse(root);<br>        <span class="hljs-keyword">return</span> root;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">traverse</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <span class="hljs-comment">/* 反中序遍历 */</span><br>        traverse(root.right);<br>        root.val += pre;<br>        pre = root.val;<br>        traverse(root.left);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>108. 将有序数组转换为二叉搜索树</title>
    <link href="/2022/12/08/108-%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <url>/2022/12/08/108-%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h2 id="将有序数组转换为二叉搜索树-链接">108.将有序数组转换为二叉搜索树-<ahref="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/">链接🚀</a></h2><h3 id="题目">题目</h3><p>给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵高度平衡 二叉搜索树。</p><p>高度平衡二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1」的二叉树。</p><figure><img src="/img/md/leetcode/108.png" alt="108" /><figcaption aria-hidden="true">108</figcaption></figure><h3 id="题解">题解</h3><h3 id="代码">代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">sortedArrayToBST</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-comment">// System.out.println( nums.length);</span><br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> traverse(nums , <span class="hljs-number">0</span> , nums.length );<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">traverse</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums , <span class="hljs-type">int</span> left , <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-comment">/* 递归终止条件 */</span><br>        <span class="hljs-keyword">if</span> (left &gt;= right) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (right - left == <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">//当两个节点相差为1时，我们应当将左节点初始化为一个节点；</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(nums[left]);<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + ((right - left) / <span class="hljs-number">2</span>); <span class="hljs-comment">//每次都取中间位置</span><br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(nums[mid]); <span class="hljs-comment">//每次将中间的值初始化为一个新的节点</span><br><br>        root.left = traverse(nums , left , mid );<br>        root.right = traverse(nums , mid + <span class="hljs-number">1</span> , right);<br><br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>669. 修剪二叉搜索树</title>
    <link href="/2022/12/08/669-%E4%BF%AE%E5%89%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <url>/2022/12/08/669-%E4%BF%AE%E5%89%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h2 id="修剪二叉搜索树-链接">669. 修剪二叉搜索树-<ahref="https://leetcode.cn/problems/trim-a-binary-search-tree/">链接🚀</a></h2><h3 id="题目">题目</h3><p>给你二叉搜索树的根节点 root ，同时给定最小边界low 和最大边界high。通过修剪二叉搜索树，使得所有节点的值在[low, high]中。修剪树不应该 改变保留在树中的元素的相对结构(即，如果没有被移除，原有的父代子代关系都应当保留)。可以证明，存在 唯一的答案 。</p><p>所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。</p><figure><img src="/img/md/leetcode/669.png" alt="669" /><figcaption aria-hidden="true">669</figcaption></figure><h3 id="题解">题解</h3><h3 id="代码">代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    <span class="hljs-comment">/* 遍历整棵树 */</span><br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">trimBST</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> &#123;<br>        <span class="hljs-comment">/* 终止条件 */</span><br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        <span class="hljs-comment">/* 判断条件 */</span><br>        <span class="hljs-keyword">if</span> (root.val &lt; low) &#123; <span class="hljs-comment">//将root.left = root.left.right; 这里有个传递性</span><br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> trimBST(root.right , low , high); <span class="hljs-comment">//会找到所有满足当前节点大于low的树；</span><br>            <span class="hljs-keyword">return</span> right; <span class="hljs-comment">//返回该棵树</span><br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (root.val &gt; high) &#123;<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> trimBST(root.left , low , high);<br>            <span class="hljs-keyword">return</span> left; <span class="hljs-comment">//返回该节点的左子树</span><br>        &#125;<br>        <br>        root.left = trimBST(root.left , low , high);<span class="hljs-comment">//将满足条件的左子树用跟节点的左子树来接住；</span><br>        root.right = trimBST(root.right , low , high);<span class="hljs-comment">//将满足条件的右子树用根节点的右子树来接住；</span><br><br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>235. 二叉搜索树的最近公共祖先</title>
    <link href="/2022/12/07/235-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"/>
    <url>/2022/12/07/235-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</url>
    
    <content type="html"><![CDATA[<h2 id="二叉搜索树的最近公共祖先-链接">235. 二叉搜索树的最近公共祖先-<ahref="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/">链接🚀</a></h2><h3 id="题目">题目</h3><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p>例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]</p><figure><img src="/img/md/leetcode/235.png" alt="235" /><figcaption aria-hidden="true">235</figcaption></figure><h3 id="题解">题解</h3><h3 id="代码">代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>450. 删除二叉搜索树中的节点</title>
    <link href="/2022/12/07/450-%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/"/>
    <url>/2022/12/07/450-%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h2 id="删除二叉搜索树中的节点-链接">450. 删除二叉搜索树中的节点-<ahref="https://leetcode.cn/problems/delete-node-in-a-bst/">链接🚀</a></h2><h3 id="题目">题目</h3><p>给定一个二叉搜索树的根节点 root 和一个值key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p><p>一般来说，删除节点可分为两个步骤：</p><p>首先找到需要删除的节点； 如果找到了，删除它。</p><figure><img src="/img/md/leetcode/450.png" alt="450" /><figcaption aria-hidden="true">450</figcaption></figure><h3 id="题解">题解</h3><h3 id="代码">代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">deleteNode</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> key)</span> &#123;<br>        <span class="hljs-comment">/* 没有找到删除的节点 */</span><br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (root.val == key) &#123;<br>            <span class="hljs-comment">// 找到匹配值</span><br>            <span class="hljs-comment">/* 待删节点的左孩子不为空，但右孩子为空 */</span><br>            <span class="hljs-keyword">if</span> (root.left == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">//情况1.</span><br>                <span class="hljs-keyword">return</span> root.right;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root.right == <span class="hljs-literal">null</span>)&#123;<span class="hljs-comment">//情况2.</span><br>                <span class="hljs-keyword">return</span> root.left;<br>            &#125;<span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">/* 待删节点的左右孩子节点都不为空，则将该节点的左孩子放到该节点的右孩子的最左节点 */</span><br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> root.right;<br>                <span class="hljs-keyword">while</span> (cur.left != <span class="hljs-literal">null</span>) &#123;<br>                    cur = cur.left;<br>                &#125;<br>                cur.left = root.left;<br>                <span class="hljs-keyword">return</span> root.right;<br>            &#125;     <br>        &#125;<br><br>        root.left = deleteNode(root.left , key);<br>        root.right = deleteNode(root.right , key);<br><br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>701. 二叉搜索树中的插入操作</title>
    <link href="/2022/12/07/701-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C/"/>
    <url>/2022/12/07/701-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h2 id="二叉搜索树中的插入操作-链接">701. 二叉搜索树中的插入操作-<ahref="https://leetcode.cn/problems/insert-into-a-binary-search-tree/">链接🚀</a></h2><h3 id="题目">题目</h3><p>给定二叉搜索树（BST）的根节点 root 和要插入树中的值 value ，将值插入二叉搜索树。返回插入后二叉搜索树的根节点。 输入数据 保证，新值和原始二叉搜索树中的任意节点值都不同。</p><p>注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。你可以返回 任意有效的结果 。</p><p>  <img src="/img/md/leetcode/701.png" alt="701" /></p><h3 id="题解">题解</h3><h3 id="代码">代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">insertIntoBST</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(val);<br>            <span class="hljs-keyword">return</span> node;<br>        &#125;<br><br>        <span class="hljs-comment">/* 如果传入的值小于当前节点的左子树，则应当遍历左子树，并且如果找到符合条件的值应当将此时的val初始化，并用root.left接住表明这是左子树 */</span><br>        <br>        <span class="hljs-keyword">if</span> (root.val &gt; val) &#123;<br>            root.left = insertIntoBST(root.left , val);<br>        &#125;<br><br>        <span class="hljs-comment">/* 如果传入的值大于当前节点的右子树，则应当遍历右子树，并且如果找到符合条件的值应当将此时的val初始化，并用root.right接住表明这是右子树 */</span><br><br>        <span class="hljs-keyword">if</span> (root.val &lt; val) &#123;<br>            root.right = insertIntoBST(root.right , val);<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>236. 二叉树的最近公共祖先</title>
    <link href="/2022/12/06/236-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"/>
    <url>/2022/12/06/236-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</url>
    
    <content type="html"><![CDATA[<h2 id="二叉树的最近公共祖先-链接">236. 二叉树的最近公共祖先-<ahref="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">链接🚀</a></h2><h3 id="题目">题目</h3><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><figure><img src="/img/md/leetcode/236.png" alt="236" /><figcaption aria-hidden="true">236</figcaption></figure><h3 id="题解">题解</h3><h3 id="代码">代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">/* 1. 利用回溯法，二叉树的后序遍历就是天然的回溯结构-代码随想录</span><br><span class="hljs-comment">       2. 若递归函数有返回值时，我们需要遍历整颗树 */</span><br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">lowestCommonAncestor</span><span class="hljs-params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == p || root == q || root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br><br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> lowestCommonAncestor(root.left , p , q);<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> lowestCommonAncestor(root.right , p , q);<br>        <span class="hljs-comment">// 若是root的左子树与右子树都不为空，则返回root，即就是root就是其最近的公共祖先</span><br>        <span class="hljs-keyword">if</span> (left != <span class="hljs-literal">null</span> &amp;&amp; right != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br>        <span class="hljs-comment">// 若是root的左子树不为空，但右子树为空，则应当返回左子树</span><br>        <span class="hljs-keyword">if</span> (left != <span class="hljs-literal">null</span> &amp;&amp; right == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> left;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (left == <span class="hljs-literal">null</span> &amp;&amp; right != <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">// 若是root的右子树不为空，但左子树为空，则应当返回右子树</span><br>            <span class="hljs-keyword">return</span> right;<br>        &#125;<span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//否则就返回为空</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>501. 二叉搜索树中的众数</title>
    <link href="/2022/12/06/501-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E4%BC%97%E6%95%B0/"/>
    <url>/2022/12/06/501-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E4%BC%97%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="二叉搜索树中的众数-链接">501. 二叉搜索树中的众数-<ahref="https://leetcode.cn/problems/find-mode-in-binary-search-tree/">链接🚀</a></h2><h3 id="题目">题目</h3><p>给你一个含重复值的二叉搜索树（BST）的根节点 root ，找出并返回 BST中的所有 众数（即，出现频率最高的元素）。</p><p>如果树中有不止一个众数，可以按 任意顺序 返回。</p><p>假定 BST 满足如下定义：</p><ul><li>结点左子树中所含节点的值 小于等于 当前节点的值</li><li>结点右子树中所含节点的值 大于等于 当前节点的值</li><li>左子树和右子树都是二叉搜索树</li></ul><figure><img src="/img/md/leetcode/501.png" alt="501" /><figcaption aria-hidden="true">501</figcaption></figure><h3 id="题解">题解</h3><h3 id="代码">代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> count;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> countMax;<br>    <span class="hljs-keyword">public</span> ArrayList&lt;Integer&gt; result;<br>    <span class="hljs-keyword">public</span> TreeNode pre;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] findMode(TreeNode root) &#123;<br>        result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        count = <span class="hljs-number">0</span>;<br>        countMax = <span class="hljs-number">0</span>;<br>        pre = <span class="hljs-literal">null</span>;<span class="hljs-comment">//标记为第一个节点</span><br>        findModels(root);<br>        <br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[result.size()];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; result.size() ; i++) &#123;<br>            res[i] = result.get(i);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">findModels</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        findModels(root.left);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rootValue</span> <span class="hljs-operator">=</span> root.val;<br><br>        <span class="hljs-comment">/* 当遇到满足两个及其以上的节点值相等时，我们将count值自加1；</span><br><span class="hljs-comment">        2.将pre前驱指针初始化为null ， 用于标记此时我们遍历的最左的节点 */</span><br>        <span class="hljs-keyword">if</span> (pre == <span class="hljs-literal">null</span> || rootValue != pre.val)&#123;<br>            count = <span class="hljs-number">1</span>;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            count++;<br>        &#125;<br><br>        <span class="hljs-comment">/* 如果count的值已经比当前记录中，最大的值大时，我们将结果集清空，记录当前结果的值，然后将此时最大的count值赋值给countMax;即就是更新count值和countMax的值 */</span><br>        <span class="hljs-keyword">if</span> (count &gt; countMax) &#123;<br>            result.clear();<span class="hljs-comment">// 清空结果集</span><br>            result.add(rootValue);<br>            countMax = count;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (count == countMax)&#123;<br>            result.add(rootValue);<br>        &#125;<br>        pre = root; <span class="hljs-comment">// 赋值给前面的指针，记录已遍历过的指针</span><br><br>        findModels(root.right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>530. 二叉搜索树的最小绝对差</title>
    <link href="/2022/12/06/530-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE/"/>
    <url>/2022/12/06/530-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="二叉搜索树的最小绝对差-链接">530. 二叉搜索树的最小绝对差-<ahref="https://leetcode.cn/problems/minimum-absolute-difference-in-bst/">链接🚀</a></h2><h3 id="题目">题目</h3><p>给你一个二叉搜索树的根节点 root ，返回树中任意两不同节点值之间的最小差值 。</p><p>差值是一个正数，其数值等于两值之差的绝对值。</p><figure><img src="/img/md/leetcode/530.png" alt="530" /><figcaption aria-hidden="true">530</figcaption></figure><h3 id="题解">题解</h3><p>与验证二叉搜索树的思路类似，通过中序遍历的方式，依次比较两个节点的值；</p><p>可以这么做的原因是因为中序遍历能得到一个有序的数组；</p><h3 id="代码">代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>    <span class="hljs-keyword">public</span> TreeNode LeftNode;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getMinimumDifference</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (root.left != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> getMinimumDifference(root.left);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (LeftNode != <span class="hljs-literal">null</span>) &#123;<br>            min = Math.min(min , root.val - LeftNode.val);<br>        &#125;<br>        LeftNode = root;<br><br>        <span class="hljs-keyword">if</span> (root.right != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> getMinimumDifference(root.right);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> min;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>98. 验证二叉搜索树</title>
    <link href="/2022/12/05/98-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <url>/2022/12/05/98-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h2 id="验证二叉搜索树-链接">98. 验证二叉搜索树-<ahref="https://leetcode.cn/problems/validate-binary-search-tree/">链接🚀</a></h2><h3 id="题目">题目</h3><p>给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。</p><p>有效 二叉搜索树定义如下：</p><p>节点的左子树只包含 小于 当前节点的数。 节点的右子树只包含 大于当前节点的数。 所有左子树和右子树自身必须也是二叉搜索树。</p><h3 id="题解">题解</h3><p>第一种 就是</p><h3 id="代码">代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; result;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValidBST</span><span class="hljs-params">(TreeNode root)</span> &#123;<br><br>        result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>        InOrder(root , result);<br><br>        <span class="hljs-comment">// System.out.println(result);</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> ; i &lt; result.size()  ; i++) &#123;<br>            <span class="hljs-keyword">if</span> (result.get(i) &lt;= result.get(i-<span class="hljs-number">1</span> ))&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">InOrder</span><span class="hljs-params">(TreeNode root , List&lt;Integer&gt; result)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        InOrder(root.left ,  result);<br>        result.add(root.val);<br>        InOrder(root.right , result);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> 中序遍历，定义一个树节点记录中序序列中上一个节点；每当遍历一个节点之后就将该节点标记为已遍历过；</span><br><span class="hljs-comment">  */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    TreeNode TraversedNode;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValidBST</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> isValidBST(root.left);<br>        <span class="hljs-keyword">if</span> (!left) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (TraversedNode != <span class="hljs-literal">null</span> &amp;&amp; root.val &lt;= TraversedNode.val) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        TraversedNode = root; <span class="hljs-comment">// 将遍历过的节点指向前一个节点</span><br><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> isValidBST(root.right);<span class="hljs-comment">//遍历右孩子</span><br>        <span class="hljs-keyword">if</span> (!right) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>700. 二叉搜索树中的搜索</title>
    <link href="/2022/12/05/700-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2/"/>
    <url>/2022/12/05/700-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="二叉搜索树中的搜索-链接">700. 二叉搜索树中的搜索-<ahref="https://leetcode.cn/problems/search-in-a-binary-search-tree/">链接🚀</a></h2><h3 id="题目">题目</h3><p>给定二叉搜索树（BST）的根节点 root 和一个整数值 val。</p><p>你需要在 BST 中找到节点值等于 val 的节点。 返回以该节点为根的子树。如果节点不存在，则返回 null 。</p><figure><img src="/img/md/leetcode/700.png" alt="700" /><figcaption aria-hidden="true">700</figcaption></figure><h3 id="题解">题解</h3><h3 id="代码">代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> 利用本题中二叉搜索树的有序树，根节点的左子树的值均小于根节点，根节点的右子树的值均大于根节点；</span><br><span class="hljs-comment">  */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">searchBST</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> val)</span> &#123;<br><br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span> || root.val == val) &#123;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (root.val &gt; val) &#123;<br>            <span class="hljs-keyword">return</span> searchBST(root.left , val);<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>           <span class="hljs-keyword">return</span> searchBST(root.right ,val);<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>543. 二叉树的直径</title>
    <link href="/2022/12/05/543-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/"/>
    <url>/2022/12/05/543-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/</url>
    
    <content type="html"><![CDATA[<h2 id="二叉树的直径-链接">543. 二叉树的直径-<ahref="https://leetcode.cn/problems/diameter-of-binary-tree/">链接🚀</a></h2><h3 id="题目">题目</h3><p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。</p><h3 id="题解">题解</h3><h3 id="代码">代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 1.采用后序遍历来解决此题 */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">diameterOfBinaryTree</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        PreOrder( root );<br>        <span class="hljs-keyword">return</span> max - <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">PreOrder</span><span class="hljs-params">(TreeNode root )</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br> <br>        <span class="hljs-type">int</span> <span class="hljs-variable">L</span> <span class="hljs-operator">=</span> PreOrder(root.left ); <span class="hljs-comment">//该节点地左子树地深度</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">R</span> <span class="hljs-operator">=</span> PreOrder(root.right); <span class="hljs-comment">//该节点地右子树地深度</span><br><br>        max = Math.max(max , L + R + <span class="hljs-number">1</span>); <span class="hljs-comment">//更新子树地最大深度</span><br><br>        <span class="hljs-keyword">return</span> Math.max(L , R) + <span class="hljs-number">1</span>; <span class="hljs-comment">// 返回当前节点为根节点地子树地最大深度；</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>437. 路径总和 III</title>
    <link href="/2022/12/04/437-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C-III/"/>
    <url>/2022/12/04/437-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C-III/</url>
    
    <content type="html"><![CDATA[<h2 id="路径总和-iii-链接">437. 路径总和 III-<ahref="https://leetcode.cn/problems/path-sum-iii/">链接🚀</a></h2><h3 id="题目">题目</h3><p>给定一个二叉树的根节点 root ，和一个整数 targetSum，求该二叉树里节点值之和等于 targetSum 的 路径 的数目。</p><p>路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p><h3 id="题解">题解</h3><h3 id="代码">代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> targetSum)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> PreOrderPath(root , targetSum); <span class="hljs-comment">// 从根节点开始的满足路径的值等于目标值的路径条数；</span><br>        res += pathSum(root.left , targetSum); <span class="hljs-comment">// 从根节点的左孩子开始的所有路径值相加等于目标值的条数；</span><br>        res += pathSum(root.right , targetSum);<span class="hljs-comment">// 从根节点的右孩子开始的所有路径值相加等于目标值的条数；</span><br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">PreOrderPath</span><span class="hljs-params">(TreeNode root ,<span class="hljs-type">long</span> targetSum)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (root.val == targetSum) &#123;<br>            ret++;<br>        &#125;<br><br>        ret += PreOrderPath(root.left , targetSum - root.val);<br>        ret += PreOrderPath(root.right , targetSum - root.val);<br><br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>617. 合并二叉树</title>
    <link href="/2022/12/04/617-%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2022/12/04/617-%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h2 id="合并二叉树-链接">617. 合并二叉树-<ahref="https://leetcode.cn/problems/merge-two-binary-trees/">链接🚀</a></h2><h3 id="题目">题目</h3><p>给你两棵二叉树： root1 和 root2 。</p><p>想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，不为null 的节点将直接作为新二叉树的节点。</p><p>返回合并后的二叉树。</p><p>注意: 合并过程必须从两个树的根节点开始。</p><h3 id="题解">题解</h3><p>本题只需要同时遍历两棵树，并以其中一颗树重新构造二叉树，并返回二叉树根节点； 因此有：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><br>root.left = <br>root.right = <br><br></code></pre></td></tr></table></figure><h3 id="代码">代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">/* </span><br><span class="hljs-comment">    以t1为根节点，用前序遍历递归的方式做</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">mergeTrees</span><span class="hljs-params">(TreeNode root1, TreeNode root2)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root1 == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> root2;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (root2 == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> root1;<br>        &#125;<br><br>        root1.val += root2.val;<br><br>        root1.left = mergeTrees(root1.left , root2.left);<br>        root1.right = mergeTrees(root1.right , root2.right);<br>        <br>        <span class="hljs-keyword">return</span> root1;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>654. 最大二叉树</title>
    <link href="/2022/12/04/654-%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2022/12/04/654-%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h2 id="最大二叉树链接">654. 最大二叉树<ahref="https://leetcode.cn/problems/maximum-binary-tree/">链接🚀</a></h2><h3 id="题目">题目</h3><h3 id="题解">题解</h3><p>本题与通过前序序列和中序序列构造二叉树以及通过后序序列和中序序列构造二叉树的思想类似，都是通过确定给动态数组边界来解答；</p><p>本题的关键点在于，如何确定新数组的起始边界；题目中说到，最大值为子树的根节点；每次都将在给定的数组区间内找到该子区间的最大值；</p><p>利用for循环找出最大值时，我们发现其可以动态更新节点索引，因为区间为左闭右开区间；因此进入递归后，不会再访问其上一轮递归的元素；</p><h3 id="代码">代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">constructMaximumBinaryTree</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">return</span> maxBinary(nums , <span class="hljs-number">0</span> , nums.length);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">maxBinary</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums , <span class="hljs-type">int</span> left , <span class="hljs-type">int</span> right)</span> &#123;<br><br>        <span class="hljs-keyword">if</span> (right - left &lt; <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">//说明两个边界仅仅挨着</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (right - left == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(nums[left]); <span class="hljs-comment">//此时为叶子节点的时候</span><br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxIndex</span> <span class="hljs-operator">=</span> left ; <br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> nums[maxIndex];<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> left + <span class="hljs-number">1</span> ; i &lt; right ; i++)&#123;<br>            <span class="hljs-keyword">if</span> (nums[i] &gt; max) &#123;<br>                max = nums[i];<br>                maxIndex = i;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(max);<br><br>        root.left = maxBinary(nums , left , maxIndex);<br>        root.right = maxBinary(nums , maxIndex + <span class="hljs-number">1</span> , right);<br><br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>105. 从前序与中序遍历序列构造二叉树</title>
    <link href="/2022/12/04/105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2022/12/04/105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h2 id="从前序与中序遍历序列构造二叉树-链接">105.从前序与中序遍历序列构造二叉树-<ahref="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">链接🚀</a></h2><h3 id="题目">题目</h3><h3 id="题解">题解</h3><p>在确定每层的左右子树划分时，应当确定中序序列根节点的index。此时中序序列inBegin- rootIndex即为左子数的节点数目； 而rootIndex - inBegin = leftOfNode可以用在划分前序数组的身上</p><h3 id="代码">代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    Map&lt;Integer , Integer&gt; map;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">buildTree</span><span class="hljs-params">(<span class="hljs-type">int</span>[] preorder, <span class="hljs-type">int</span>[] inorder)</span> &#123;<br>        map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; inorder.length ; i++) &#123;<br>            map.put(inorder[i] , i); <span class="hljs-comment">//将中序数组放入到map中</span><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> PreAndInBuild(preorder , <span class="hljs-number">0</span> , preorder.length,<br>                            inorder , <span class="hljs-number">0</span> , inorder.length);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">PreAndInBuild</span><span class="hljs-params">(<span class="hljs-type">int</span>[] preorder ,<span class="hljs-type">int</span> preBein , <span class="hljs-type">int</span> preEnd,<span class="hljs-type">int</span>[] inorder , <span class="hljs-type">int</span> inBegin , <span class="hljs-type">int</span> inEnd )</span> &#123;<br>        <span class="hljs-keyword">if</span> (preBein &gt;= preEnd || inBegin &gt;= inEnd) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">rootIndex</span> <span class="hljs-operator">=</span> map.get(preorder[preBein]); <span class="hljs-comment">// 得到子树的根节点的索引</span><br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(inorder[rootIndex]); <span class="hljs-comment">//创建根节点</span><br><br>        <span class="hljs-comment">//重新分配子树的区间</span><br>        <span class="hljs-comment">/* </span><br><span class="hljs-comment">        1. 左子树的区间：以中序序列的根节点位置 将中序序列分为两个子树的区间</span><br><span class="hljs-comment">        int LeftOfNode = rootIndex - inBegin;保存中序序列左子树的个数，确定前序序列中的左子树的个数；</span><br><span class="hljs-comment">        int RightOfNode = </span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">LeftOfNode</span> <span class="hljs-operator">=</span> rootIndex - inBegin;<br><br>        root.left = PreAndInBuild(preorder , preBein + <span class="hljs-number">1</span> , preBein + LeftOfNode + <span class="hljs-number">1</span>,  inorder , inBegin , rootIndex);<br><br>        root.right = PreAndInBuild(preorder , preBein + LeftOfNode +<span class="hljs-number">1</span>, preEnd  , inorder , rootIndex + <span class="hljs-number">1</span> , inEnd); <br><br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>106. 从中序与后序遍历序列构造二叉树</title>
    <link href="/2022/12/03/106-%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2022/12/03/106-%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h2 id="从中序与后序遍历序列构造二叉树-链接">106.从中序与后序遍历序列构造二叉树-<ahref="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">链接🚀</a></h2><h3 id="题目">题目</h3><h3 id="题解">题解</h3><h3 id="代码">代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    Map&lt;Integer , Integer&gt; map;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">buildTree</span><span class="hljs-params">(<span class="hljs-type">int</span>[] inorder, <span class="hljs-type">int</span>[] postorder)</span> &#123;<br>        map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;Integer , Integer&gt;();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; inorder.length ; i++) &#123;<br>            map.put(inorder[i] , i);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> findnode(inorder , <span class="hljs-number">0</span> , inorder.length ,<br>                        postorder , <span class="hljs-number">0</span> , postorder.length);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">findnode</span><span class="hljs-params">(<span class="hljs-type">int</span>[] inorder , <span class="hljs-type">int</span> inbegin , <span class="hljs-type">int</span> inend, <span class="hljs-type">int</span>[] postorder , <span class="hljs-type">int</span> postbegin , <span class="hljs-type">int</span> postend)</span> &#123;<br>        <span class="hljs-comment">//递归返回条件</span><br>        <span class="hljs-keyword">if</span> (inbegin &gt;= inend || postbegin &gt;= postend) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">inorderindex</span> <span class="hljs-operator">=</span> map.get(postorder[postend - <span class="hljs-number">1</span>]); <span class="hljs-comment">//得到中序序列的索引</span><br>        <span class="hljs-comment">//构造节点</span><br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(inorder[inorderindex]);<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">leftofnode</span> <span class="hljs-operator">=</span> inorderindex - inbegin; <span class="hljs-comment">//确定右孩子的个数</span><br><br>        root.left = findnode(inorder , inbegin , inorderindex,<br>                            postorder , postbegin , postbegin + leftofnode);<br><br>        root.right = findnode(inorder , inorderindex + <span class="hljs-number">1</span> , inend,<br>                            postorder , postbegin + leftofnode , postend - <span class="hljs-number">1</span>);<br><br>        <br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>113. 路径总和 II</title>
    <link href="/2022/12/02/113-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C-II/"/>
    <url>/2022/12/02/113-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C-II/</url>
    
    <content type="html"><![CDATA[<h2 id="路径总和-ii-链接">113. 路径总和 II-<ahref="https://leetcode.cn/problems/path-sum-ii/">链接🚀</a></h2><h3 id="题目">题目</h3><p>给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有从根节点到叶子节点 路径总和等于给定目标和的路径。</p><p>叶子节点 是指没有子节点的节点。</p><h3 id="题">题</h3><p>本题思路： 前序遍历将所有的叶子节点的路径输出。然后计算从根节点到叶子节点的值是否等于目标值，若等于，则将该item加入。</p><h3 id="代码">代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">pathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> targetSum)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        List&lt;List&lt;Integer&gt;&gt; resultall = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        List&lt;Integer&gt; paths = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>        preorder(root , paths , result);<br>       <br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; result.size() ; i++) &#123;<br>             <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-type">List</span> <span class="hljs-variable">item</span> <span class="hljs-operator">=</span> result.get(i);<br>            <span class="hljs-comment">// System.out.println(item);</span><br>            <span class="hljs-keyword">for</span> ( <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; j &lt; item.size() ; j++)&#123;<br>                temp = (Integer)item.get(j) + temp;<br>            &#125;<br>            System.out.println(temp);<br>            <span class="hljs-keyword">if</span> (temp == targetSum) &#123;<br>                resultall.add(item);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> resultall;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">preorder</span><span class="hljs-params">(TreeNode root , List&lt;Integer&gt; paths , List&lt;List&lt;Integer&gt;&gt; result)</span> &#123;<br>        paths.add(root.val);<br><br>        <span class="hljs-keyword">if</span> (root.left == <span class="hljs-literal">null</span> &amp;&amp; root.right == <span class="hljs-literal">null</span>) &#123;<br>            result.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(paths));<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (root.left != <span class="hljs-literal">null</span>) &#123;<br>            preorder(root.left , paths , result);<br>            paths.remove(paths.size() - <span class="hljs-number">1</span>); <span class="hljs-comment">// 回溯</span><br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (root.right != <span class="hljs-literal">null</span>) &#123;<br>            preorder(root.right , paths , result);<br>            paths.remove(paths.size() - <span class="hljs-number">1</span>); <span class="hljs-comment">// 回溯</span><br>        &#125;<br>    &#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 代码随想录思路</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">pathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> targetSum)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-comment">// List&lt;List&lt;Integer&gt;&gt; resultall = new ArrayList&lt;&gt;();</span><br>        List&lt;Integer&gt; paths = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br><br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br><br>        preorder(root , targetSum , paths , result);<br><br><br>        <span class="hljs-keyword">return</span> result;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">preorder</span><span class="hljs-params">(TreeNode root , <span class="hljs-type">int</span> targetSum ,  List&lt;Integer&gt; paths , List&lt;List&lt;Integer&gt;&gt; result)</span> &#123;<br>        paths.add(root.val);<br><br>        <span class="hljs-keyword">if</span> (root.left == <span class="hljs-literal">null</span> &amp;&amp; root.right == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (targetSum - root.val == <span class="hljs-number">0</span>) &#123;<br>                result.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(paths));<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (root.left != <span class="hljs-literal">null</span>) &#123;<br>            preorder(root.left , targetSum - root.val , paths , result);<br>            paths.remove(paths.size() - <span class="hljs-number">1</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (root.right != <span class="hljs-literal">null</span>) &#123;<br>            preorder(root.right , targetSum - root.val , paths , result);<br>            paths.remove(paths.size() - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>112. 路径总和</title>
    <link href="/2022/12/02/112-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/"/>
    <url>/2022/12/02/112-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h2 id="路径总和-链接">112. 路径总和-<ahref="https://leetcode.cn/problems/path-sum/">链接🚀</a></h2><h3 id="题目">题目</h3><p>给你二叉树的根节点 root 和一个表示目标和的整数 targetSum。判断该树中是否存在 根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回true ；否则，返回 false 。</p><p>叶子节点 是指没有子节点的节点。</p><h3 id="题解">题解</h3><h3 id="代码">代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">/* 1. 采用前序遍历。中、左、右的顺序</span><br><span class="hljs-comment">       2. 遍历到当前值就将该值与目标值做减法</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasPathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> targetSum)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        targetSum -= root.val; <span class="hljs-comment">// 自顶向下减</span><br><br>        <span class="hljs-keyword">if</span> (root.left == <span class="hljs-literal">null</span> &amp;&amp; root.right == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> targetSum == <span class="hljs-number">0</span>; <span class="hljs-comment">//返回targetSum是否等于0的判断</span><br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (root.left != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> hasPathSum(root.left , targetSum);<br>            <span class="hljs-keyword">if</span> (left) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span> (root.right != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> hasPathSum(root.right , targetSum);<br>            <span class="hljs-keyword">if</span> (right) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>513. 找树左下角的值</title>
    <link href="/2022/12/01/513-%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC/"/>
    <url>/2022/12/01/513-%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<h2 id="找树左下角的值-链接">513. 找树左下角的值-<ahref="https://leetcode.cn/problems/find-bottom-left-tree-value/">链接🚀</a></h2><h3 id="题目">题目</h3><h3 id="题解">题解</h3><p>对二叉树迭代遍历，层序遍历，输出最后一层的第一个节点；注意需要将object对象先转化为string类型再转化为integer类型；转化代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer.parseInt(String.valueOf(res.get(<span class="hljs-number">0</span>)))<br></code></pre></td></tr></table></figure><h3 id="代码">代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findBottomLeftValue</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">return</span> levelordertravel(root);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">levelordertravel</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        Queue&lt;TreeNode&gt; que = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><br>        List&lt;List&lt;Integer&gt;&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        que.add(root);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">deep</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (!que.isEmpty()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> que.size();<br>            deep++;<br>            List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            <span class="hljs-keyword">while</span> (size &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> que.poll();<br>                list.add(node.val);<br><br>                <span class="hljs-keyword">if</span> (node.left != <span class="hljs-literal">null</span>) &#123;<br>                    que.add(node.left);<br>                &#125;<br><br>                <span class="hljs-keyword">if</span> (node.right != <span class="hljs-literal">null</span>) &#123;<br>                    que.add(node.right);<br>                &#125;<br>                size--;<br>            &#125;<br>            result.add(list);<br>        &#125;<br>        <span class="hljs-type">List</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> result.get(deep - <span class="hljs-number">1</span>);<br>        <br>        System.out.println();<br>        <span class="hljs-comment">// res = res.get(0);</span><br>        <span class="hljs-keyword">return</span> Integer.parseInt(String.valueOf(res.get(<span class="hljs-number">0</span>)));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>404. 左叶子之和</title>
    <link href="/2022/12/01/404-%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C/"/>
    <url>/2022/12/01/404-%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h2 id="左叶子之和-链接">404. 左叶子之和-<ahref="https://leetcode.cn/problems/sum-of-left-leaves/">链接🚀</a></h2><h3 id="题目">题目</h3><h3 id="题解">题解</h3><p>采用递归的方法，后序遍历，这里注意的点是，当找到符合结果的时，先将该值用一个临时变量保存起来，最后再将其值返回</p><h3 id="代码">代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 左、右、中遍历顺序</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sumOfLeftLeaves</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">leftnum</span> <span class="hljs-operator">=</span> sumOfLeftLeaves(root.left);<br>        <span class="hljs-comment">// System.out.println(leftnum);</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">rightnum</span> <span class="hljs-operator">=</span> sumOfLeftLeaves(root.right);<br>        <span class="hljs-comment">// System.out.println(rightnum);</span><br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">midnum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">if</span> (root.left != <span class="hljs-literal">null</span> &amp;&amp; root.left.left == <span class="hljs-literal">null</span> &amp;&amp; root.left.right == <span class="hljs-literal">null</span>) &#123;<br>            midnum = root.left.val;<br>            <span class="hljs-comment">// return root.left.val;</span><br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> leftnum + rightnum + midnum;<br>        <span class="hljs-comment">// return leftnum + rightnum;</span><br><br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Maven-全局配置</title>
    <link href="/2022/12/01/Maven-%E5%85%A8%E5%B1%80%E9%85%8D%E7%BD%AE/"/>
    <url>/2022/12/01/Maven-%E5%85%A8%E5%B1%80%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h4 id="进入初始页面点击-customize">进入初始页面点击 customize</h4><figure><img src="/img/md/java/maven.png" title="图片" alt="这是图片" /><figcaption aria-hidden="true">这是图片</figcaption></figure><h4 id="点击configure">点击configure</h4><figure><img src="/img/md/java/maven1.png" title="图片" alt="这是图片" /><figcaption aria-hidden="true">这是图片</figcaption></figure><h4id="点击build-execution--build-tools--maven--maven-base-path--">点击BuildExecution -&gt;Build tools -&gt;maven -&gt;Maven base path -&gt;</h4><figure><img src="/img/md/java/maven2.png" title="图片" alt="这是图片" /><figcaption aria-hidden="true">这是图片</figcaption></figure><h4 id="最后点击apply---ok">最后点击apply -&gt; ok</h4>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>Maven配置</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>257. 二叉树的所有路径</title>
    <link href="/2022/12/01/257-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84/"/>
    <url>/2022/12/01/257-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84/</url>
    
    <content type="html"><![CDATA[<h2 id="二叉树的所有路径-链接">257. 二叉树的所有路径-<ahref="https://leetcode.cn/problems/binary-tree-paths/">链接🚀</a></h2><h3 id="题目">题目</h3><h3 id="题解">题解</h3><h3 id="代码">代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 错误思路：采用后序遍历的方式</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">binaryTreePaths</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;String&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;(); <span class="hljs-comment">//初始化一个栈</span><br><br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br><br>        stack.push(root);<br>        <span class="hljs-keyword">while</span> (root != <span class="hljs-literal">null</span> || !stack.isEmpty()) &#123;<br>            <span class="hljs-keyword">while</span> (root != <span class="hljs-literal">null</span>) &#123;<br>                stack.push(root);<br>                root = root.left;<br>            &#125;<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> stack.peek(); <span class="hljs-comment">// 取栈顶元素</span><br><br>            <span class="hljs-keyword">if</span> (node.right != <span class="hljs-literal">null</span>) &#123;<br>                root = node.right;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (node.right == <span class="hljs-literal">null</span> &amp;&amp; node.left == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">while</span> (!stack.isEmpty()) &#123;<br>                    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> stack.pop();<br>                    result.add(res.val + <span class="hljs-string">&quot;-&gt;&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 正确思路：前序遍历时，保存遍历的每个节点</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">binaryTreePaths</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>       List&lt;String&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>       List&lt;Integer&gt; paths = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>       <span class="hljs-keyword">if</span> ( root == <span class="hljs-literal">null</span>) &#123;<br>           <span class="hljs-keyword">return</span> result;<br>       &#125;<br><br>       preordertravel(root , paths , result);<br><br>       <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">preordertravel</span><span class="hljs-params">(TreeNode root , List&lt;Integer&gt; paths , List&lt;String&gt; result)</span> &#123;<br>        paths.add(root.val); <span class="hljs-comment">// 中</span><br><br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">if</span> (root.left == <span class="hljs-literal">null</span> &amp;&amp; root.right == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; paths.size() - <span class="hljs-number">1</span> ; i++) &#123;<br>                sb.append(paths.get(i)).append(<span class="hljs-string">&quot;-&gt;&quot;</span>); <span class="hljs-comment">//从第一个元素的后面依次添加-&gt;</span><br>            &#125;<br>            sb.append(paths.get(paths.size() - <span class="hljs-number">1</span>));<br>            result.add(sb.toString());<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (root.left != <span class="hljs-literal">null</span>) &#123;<br>            preordertravel(root.left , paths , result);<br>            paths.remove(paths.size() - <span class="hljs-number">1</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (root.right != <span class="hljs-literal">null</span>) &#123;<br>            preordertravel(root.right , paths , result);<br>            paths.remove(paths.size() - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>110. 平衡二叉树</title>
    <link href="/2022/11/30/110-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2022/11/30/110-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h2 id="平衡二叉树-链接">110. 平衡二叉树-<ahref="https://leetcode.cn/problems/balanced-binary-tree/">链接🚀</a></h2><h3 id="题目">题目</h3><p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p><p>本题中，一棵高度平衡二叉树定义为：</p><p>一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。</p><h3 id="题解">题解</h3><p>无论是迭代遍历还是递归遍历：逻辑都是从该树的最左的孩子进行遍历，从下往上依次返回节点的高度，当每层的高度差大于1时，将该子树返回值为-1。；</p><p>递归的单层逻辑如下：</p><p>若传入的节点为空，则返回零；</p><p>根据后序遍历的原则，左，右根节点，每层分别得到左右子树的高度，若左右子树的高度差大于1，则为非平衡树，应当返回-1；</p><p>每次得到一个节点的高度后，先判断该节点的高度是否为-1，若为-1则应当返回一个-1；</p><h3 id="代码">代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* </span><br><span class="hljs-comment">迭代法思路：</span><br><span class="hljs-comment">采用后序迭代遍历时，按照左、右、根的顺序，将元素入栈。而当最左的孩子栈出后的，对右孩子的进入进行判断。若左右孩子的高度差的绝对值大于1，则直接返回false。</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-comment">/* </span><br><span class="hljs-comment"> 递归三部曲：</span><br><span class="hljs-comment"> 1. 确定输入类型和返回类型</span><br><span class="hljs-comment"> 2. 确定递归的终止条件</span><br><span class="hljs-comment"> 3. 确定单层递归的逻辑</span><br><span class="hljs-comment">  */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isBalanced</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">return</span> getdeepth(root) != -<span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getdeepth</span> <span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">leftdeepth</span> <span class="hljs-operator">=</span> getdeepth(root.left);<br>        <span class="hljs-keyword">if</span> (leftdeepth == -<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">rightdeepth</span> <span class="hljs-operator">=</span> getdeepth(root.right);<br>        <span class="hljs-keyword">if</span> (rightdeepth == -<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (Math.abs(leftdeepth - rightdeepth) &gt; <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> Math.max(leftdeepth , rightdeepth) + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 迭代法求解步骤：</span><br><span class="hljs-comment">  1. 先编写一个函数，能根据输入的节点返回一个该节点为子树的二叉树的高；</span><br><span class="hljs-comment">  2. 使用后序遍历。根据左、右、中的顺序入栈，先最左孩子入栈，当该节点的左右子树为空或者左右子树为遍历过的右子树，则返回层高；</span><br><span class="hljs-comment">  并将该节点出栈，用一个指针指向当前遍历过的节点，取栈顶元素，当栈顶元素的右孩子不为空时，则将该右孩子入栈，（因为之前入栈时，已经将最左孩子入栈，即就是遍历过左孩子）；其本质依然是利用了借助了栈。本质和递归一样都是利用了栈这种数据结构，只是递归法返回的是每个左右节点的高度，并进行比较是否大于1，大于1则为非平衡树，将其返回-1。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isBalanced</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// 初始化一个遍历过的节点指针</span><br>        <span class="hljs-keyword">while</span> (root != <span class="hljs-literal">null</span> || !stack.isEmpty())&#123;<br>            <span class="hljs-keyword">while</span> (root != <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">//左孩子入栈</span><br>                stack.push(root);<br>                root = root.left;<br>            &#125;<br><br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> stack.peek() ; <span class="hljs-comment">//取栈顶元素</span><br><br>            <span class="hljs-keyword">if</span> (node.right == <span class="hljs-literal">null</span> || node.right == pre) &#123;<br>                <span class="hljs-keyword">if</span> (Math.abs(getdeepthlevel(node.left) - getdeepthlevel(node.right)) &gt; <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">//如果两颗子树的高度差大于1，则返回false;</span><br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>                stack.pop(); <span class="hljs-comment">// 遍历的当前元素出栈</span><br>                pre = node; <span class="hljs-comment">//记录一下当前遍历过的节点</span><br>                node = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 当前的node置为空</span><br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                root = node.right; <span class="hljs-comment">//将此时的右孩子入栈</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getdeepthlevel</span> <span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        Queue&lt;TreeNode&gt; que = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        que.offer(root);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">deepth</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (!que.isEmpty())&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> que.size();<br>            deepth++;<br>            <span class="hljs-keyword">while</span> (size &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">levelnode</span> <span class="hljs-operator">=</span> que.poll();<br>                <span class="hljs-keyword">if</span> (levelnode.left != <span class="hljs-literal">null</span>) &#123;<br>                    que.offer(levelnode.left);<br>                &#125;<br><br>                <span class="hljs-keyword">if</span> (levelnode.right != <span class="hljs-literal">null</span>) &#123;<br>                    que.offer(levelnode.right);<br>                &#125;<br><br>                size--;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> deepth;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>222. 完全二叉树的节点个数</title>
    <link href="/2022/11/30/222-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0/"/>
    <url>/2022/11/30/222-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="完全二叉树的节点个数-链接">222. 完全二叉树的节点个数-<ahref="https://leetcode.cn/problems/count-complete-tree-nodes/">链接🚀</a></h2><h3 id="题目">题目</h3><h3 id="题解">题解</h3><h3 id="代码">代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//直接采用递归的前序遍历写出该解法，遍历每层的时候，将该值记录保存</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countNodes</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        countNodespreorder(root);<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">countNodespreorder</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        count++;<br>        countNodespreorder(root.left);<br>        countNodespreorder(root.right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 同时遍历两个子树，每访问一个子树的根节点，则将子树的值自加1  */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countNodes</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>       <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>       &#125;<br><br>       <span class="hljs-keyword">return</span> countNodes(root.left) + countNodes(root.right) + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 这份算法没看懂</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countNodes</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">leftdeepth</span> <span class="hljs-operator">=</span> getdeepth(root.left);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rightdeepth</span> <span class="hljs-operator">=</span> getdeepth(root.right);<br><br>        <span class="hljs-keyword">if</span> (leftdeepth == rightdeepth) &#123;<br>            <span class="hljs-keyword">return</span> (<span class="hljs-number">1</span> &lt;&lt; leftdeepth) + countNodes(root.right);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> (<span class="hljs-number">1</span> &lt;&lt; rightdeepth) + countNodes(root.left);<br>        &#125;<br>        <br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getdeepth</span><span class="hljs-params">(TreeNode node)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">deepth</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span> (node != <span class="hljs-literal">null</span>) &#123;<br>            node = node.left;<br>            deepth++;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> deepth;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>559. N 叉树的最大深度</title>
    <link href="/2022/11/29/559-N-%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/"/>
    <url>/2022/11/29/559-N-%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<h2 id="n-叉树的最大深度链接">559. N 叉树的最大深度<ahref="https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/">链接🚀</a></h2><h3 id="题目">题目</h3><h3 id="题解">题解</h3><p><ahref="public\2022\11\28\104-二叉树的最大深度\index.html">104</a></p><h3 id="代码">代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxDepth</span><span class="hljs-params">(Node root)</span> &#123;<br><br>        Queue&lt;Node&gt; que = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        que.add(root);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">deepth</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> ( !que.isEmpty()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> que.size(); <br>            deepth++;<br>            <span class="hljs-keyword">while</span> (size &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-type">Node</span> <span class="hljs-variable">levelnode</span> <span class="hljs-operator">=</span> que.poll();<br><br>                List&lt;Node&gt; childrens = levelnode.children;<br>                <span class="hljs-keyword">for</span>(Node children : childrens)&#123;<br>                    que.add(children);<br>                &#125;<br><br>                size--;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> deepth;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>100. 相同的树</title>
    <link href="/2022/11/29/100-%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91/"/>
    <url>/2022/11/29/100-%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h2 id="相同的树-链接">100. 相同的树-<ahref="https://leetcode.cn/problems/same-tree/">链接🚀</a></h2><h3 id="题目">题目</h3><h3 id="题解">题解</h3><p>同时遍历两颗树，判断同时判断遍历到当前节点是否为空，</p><p>条件如下：</p><ol type="1"><li>1号节点的非空，2号节点为空，则为false;</li><li>1号节点的为空，2号节点非空，则为false;</li><li>1号节点的为空，2号节点为空，则为true;</li><li>1号节点的值与2号节点的值不相等，则为false;</li></ol><h3 id="代码">代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSameTree</span><span class="hljs-params">(TreeNode p, TreeNode q)</span> &#123;<br><br>        <span class="hljs-keyword">return</span> compare(p , q);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(TreeNode p , TreeNode q)</span> &#123;<br>        <span class="hljs-keyword">if</span> (p != <span class="hljs-literal">null</span> &amp;&amp; q == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">null</span> &amp;&amp; q != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">null</span> &amp;&amp; q == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (p.val != q.val) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> isSameTree(p.left , q.left);<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> isSameTree(p.right , q.right);<br><br>        <span class="hljs-keyword">return</span> left &amp;&amp; right;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>101. 对称二叉树</title>
    <link href="/2022/11/29/101-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2022/11/29/101-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h2 id="对称二叉树-链接">101. 对称二叉树-<ahref="https://leetcode.cn/problems/symmetric-tree/">链接🚀</a></h2><h3 id="题目">题目</h3><p>给你一个二叉树的根节点 root ， 检查它是否轴对称。</p><h3 id="题解">题解</h3><p>同时对两个二叉树的子树进行遍历。</p><h3 id="代码">代码</h3><p>错误思路</p><p>当二叉树中的某些节点为空节点时，无法采用反转二叉树的遍历方法来判断，因为反转过后的二叉树序列都一样的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSymmetric</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span>  (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        List&lt;Integer&gt; list1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        List&lt;Integer&gt; list2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        list1 = binaryTreeRecursion(root.left , list1); <span class="hljs-comment">// 左子树</span><br>        list2 = binaryTreeSubConvert(root.right  , list2); <span class="hljs-comment">// 翻转右子树</span><br><br>        <span class="hljs-keyword">return</span> list1.equals(list2);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> List <span class="hljs-title function_">binaryTreeRecursion</span> <span class="hljs-params">(TreeNode root , List list)</span> &#123;<br>        <span class="hljs-comment">// List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-comment">// list.add(1);</span><br>            <span class="hljs-keyword">return</span> list;<br>        &#125;<br>        list.add(root.val);<br>        binaryTreeRecursion(root.left , list);<br>        binaryTreeRecursion(root.right , list);<br><br>        <span class="hljs-keyword">return</span> list;<br>    &#125; <br><br>    <span class="hljs-keyword">public</span> List <span class="hljs-title function_">binaryTreeSubConvert</span> <span class="hljs-params">(TreeNode root , List list)</span> &#123;<br>        <span class="hljs-comment">// List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-comment">// list.add(1);</span><br>            <span class="hljs-keyword">return</span> list;<br>        &#125;<br><br>        list.add(root.val);<br>        swap(root);<br><br>        binaryTreeRecursion(root.left , list);<br>        binaryTreeRecursion(root.right , list);<br><br>        <span class="hljs-keyword">return</span> list;<br>    &#125; <br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> root.right;<br>        root.right = root.left;<br>        root.left = temp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>正确思路：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSymmetric</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span>  (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> compare(root.left , root.right);<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(TreeNode left , TreeNode right)</span> &#123;<br>        <span class="hljs-comment">/* </span><br><span class="hljs-comment">            同时遍历根节点的两个左右子树。</span><br><span class="hljs-comment">            先遍历外侧，左节点的左孩子和右节点的右孩子是否相等；若不相等肯定为false left != null &amp;&amp; rright == null </span><br><span class="hljs-comment">            再遍历内侧，左节点的右孩子和右节点的左孩子是否相等；若不相等肯定为flase  right != null &amp;&amp; rleft == null</span><br><span class="hljs-comment">            如果值不相等，则两个子树也是非对称的 ， 返回为false</span><br><span class="hljs-comment">            如果两个左右孩子相等，则返回为true</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">if</span> (left != <span class="hljs-literal">null</span> &amp;&amp; right == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (right != <span class="hljs-literal">null</span> &amp;&amp; left == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (left == <span class="hljs-literal">null</span> &amp;&amp; right == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> ( left.val != right.val) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">outside</span> <span class="hljs-operator">=</span> compare(left.left , right.right); <span class="hljs-comment">// 比较外侧</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">inside</span> <span class="hljs-operator">=</span> compare(right.left , left.right); <span class="hljs-comment">// 比较内侧</span><br><br>        <span class="hljs-keyword">return</span> outside &amp;&amp; inside;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>226. 翻转二叉树</title>
    <link href="/2022/11/29/226-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2022/11/29/226-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h2 id="翻转二叉树-链接">226. 翻转二叉树-<ahref="https://leetcode.cn/problems/invert-binary-tree/">链接🚀</a></h2><h3 id="题目">题目</h3><h3 id="题解">题解</h3><p>本题采用层序迭代法或者递归法进行解答：当采用递归法时，每当遍历到新的节点，就将该节点的左右节点采用swap函数进行交换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> root.right;<br>        root.right = root.left;<br>        root.left = temp;<br>    &#125;<br></code></pre></td></tr></table></figure><p>而采用层序迭代法时，同样地，在每输出一个节点的时候就采用swap函数进行交换，然后再将交换后的左右节点放入队列中。</p><h3 id="代码">代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">invertTree</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-comment">// return invertTreeLeveltra(root);</span><br>        <span class="hljs-keyword">return</span> invertTreeIterator(root);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">invertTreeIterator</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        Queue&lt;TreeNode&gt; que = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br><br>        que.add(root);<br>        swap(root);<br>        <br>        invertTreeIterator(root.left);<br>        invertTreeIterator(root.right);<br><br>        <span class="hljs-keyword">return</span> root;<br><br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">invertTreeLeveltra</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        Queue&lt;TreeNode&gt; que = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-comment">// Queue&lt;TreeNode&gt; quetmp = new LinkedList&lt;&gt;();</span><br>        <span class="hljs-comment">// Stack&lt;TreeNode&gt; stack = new LinkedList&lt;&gt;();</span><br><br>        <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">null</span>) &#123;<br>            que.add(root);<br>        &#125;<br><br>        <span class="hljs-keyword">while</span> (!que.isEmpty()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> que.size();<br>            <br>            <span class="hljs-keyword">while</span> (size &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> que.poll();<br>                swap(node);<br><br>                <span class="hljs-keyword">if</span> (node.right != <span class="hljs-literal">null</span>) &#123;<br>                    que.add(node.right);<br>                &#125;<br><br>                <span class="hljs-keyword">if</span> (node.left != <span class="hljs-literal">null</span>) &#123;<br>                    que.add(node.left);<br>                &#125;<br>                size--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> root.right;<br>        root.right = root.left;<br>        root.left = temp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>111. 二叉树的最小深度</title>
    <link href="/2022/11/28/111-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6/"/>
    <url>/2022/11/28/111-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<h2 id="二叉树的最小深度-链接">111. 二叉树的最小深度-<ahref="https://leetcode.cn/problems/minimum-depth-of-binary-tree/">链接🚀</a></h2><h3 id="题目">题目</h3><h3 id="题解">题解</h3><p>在原有的迭代法的基础上，层序遍历二叉树时，当我们遍历节点的右孩子和左孩子同时为空时，我们就返回</p><h3 id="代码">代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minDepth</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        Queue&lt;TreeNode&gt; que = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        que.add(root);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">deepth</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (!que.isEmpty())&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> que.size();<br>            deepth++;<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; size ; i++)&#123;<br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> que.poll();<span class="hljs-comment">//出队</span><br>                <span class="hljs-keyword">if</span> (node.left == <span class="hljs-literal">null</span> &amp;&amp; node.right == <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-keyword">return</span> deepth;<br>                    <span class="hljs-comment">//break; 如果使用这种方式，此时队列中的右孩子并不为空，外层循环会继续，导致拿不到deepth的值；</span><br>                &#125;<br><br>                <span class="hljs-keyword">if</span> (node.left != <span class="hljs-literal">null</span>)&#123;<br>                    que.add(node.left);<br>                &#125;<br><br>                <span class="hljs-keyword">if</span> (node.right != <span class="hljs-literal">null</span>)&#123;<br>                    que.add(node.right);<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-comment">// while ( size &gt; 0) &#123;</span><br>                <br>            <span class="hljs-comment">//     size--;</span><br>            <span class="hljs-comment">// &#125;</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> deepth;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>104. 二叉树的最大深度</title>
    <link href="/2022/11/28/104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/"/>
    <url>/2022/11/28/104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<h2 id="二叉树的最大深度--链接">104. 二叉树的最大深度 -<ahref="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">链接🚀</a></h2><h3 id="题目">题目</h3><h3 id="题解">题解</h3><p>在循坏外制定一个新的记录深度的记录器 intdeepth。然后将该记录器每遍历完一层，该累加器自加1。</p><h3 id="代码">代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxDepth</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        Queue&lt;TreeNode&gt; que = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-comment">// Deque&lt;TreeNode&gt; que = new LinkedList&lt;&gt;();</span><br>        <span class="hljs-keyword">if</span> ( root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        que.add(root);<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">deepth</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (!que.isEmpty())&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> que.size();<br>            deepth++;<br>            <span class="hljs-keyword">while</span> (size &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> que.poll();<br><br>                <span class="hljs-keyword">if</span> (node.left != <span class="hljs-literal">null</span>)&#123;<br>                    que.add(node.left);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (node.right != <span class="hljs-literal">null</span>)&#123;<br>                    que.add(node.right);<br>                &#125;<br>                size--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> deepth;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>117. 填充每个节点的下一个右侧节点指针Ⅱ</title>
    <link href="/2022/11/28/117-%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88%E2%85%A1/"/>
    <url>/2022/11/28/117-%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88%E2%85%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="填充每个节点的下一个右侧节点指针ⅱ-链接">117.填充每个节点的下一个右侧节点指针Ⅱ-<ahref="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/">链接🚀</a></h2><h3 id="题目">题目</h3><h3 id="题解">题解</h3><p>思路和代码和116题一模一样</p><h3 id="代码">代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> Node <span class="hljs-title function_">connect</span><span class="hljs-params">(Node root)</span> &#123;<br>        Queue&lt;Node&gt; que = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-comment">// Deque&lt;Node&gt; que = new LinkedList&lt;&gt;();</span><br>        <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">null</span>) &#123;<br>            que.add(root);<br>        &#125;<br><br>        <span class="hljs-keyword">while</span> (!que.isEmpty())&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> que.size(); <span class="hljs-comment">// 获取层数节点数</span><br>            <span class="hljs-comment">//保留每层的头节点</span><br>            <span class="hljs-type">Node</span> <span class="hljs-variable">levelhead</span> <span class="hljs-operator">=</span> que.poll();<br>            <span class="hljs-keyword">if</span> (levelhead.left != <span class="hljs-literal">null</span>)&#123;<br>                que.add(levelhead.left);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (levelhead.right != <span class="hljs-literal">null</span>)&#123;<br>                que.add(levelhead.right);<br>            &#125;<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> ; i &lt; size ; i++)&#123;<br>                <span class="hljs-type">Node</span> <span class="hljs-variable">levelnext</span> <span class="hljs-operator">=</span> que.poll();<br>                System.out.println(levelnext.val);<br>                <span class="hljs-keyword">if</span> (levelnext.left != <span class="hljs-literal">null</span>)&#123;<br>                    que.add(levelnext.left);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (levelnext.right != <span class="hljs-literal">null</span>)&#123;<br>                    que.add(levelnext.right);<br>                &#125;<br>                levelhead.next = levelnext;<br>                levelhead = levelnext;<br>            &#125;<br>            <span class="hljs-comment">// while (size &gt; 1)&#123;</span><br>                <br>            <span class="hljs-comment">//     size--;</span><br>            <span class="hljs-comment">// &#125;</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>116. 填充每个节点的下一个右侧节点指针</title>
    <link href="/2022/11/28/116-%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88/"/>
    <url>/2022/11/28/116-%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88/</url>
    
    <content type="html"><![CDATA[<h2 id="填充每个节点的下一个右侧节点指针-链接">116.填充每个节点的下一个右侧节点指针-<ahref="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/">链接🚀</a></h2><h3 id="题目">题目</h3><h3 id="题解">题解</h3><p>在原有的迭代法层序遍历的基础上，我们采用一个队列的数据结构，保留头节点的信息的做法，将层中头节点之后的节点，利用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">head.next = <span class="hljs-type">node</span><br><span class="hljs-variable">head</span> <span class="hljs-operator">=</span> node<br></code></pre></td></tr></table></figure><p>的形式解决。</p><h3 id="代码">代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> Node <span class="hljs-title function_">connect</span><span class="hljs-params">(Node root)</span> &#123;<br>        Queue&lt;Node&gt; que = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-comment">// Deque&lt;Node&gt; que = new LinkedList&lt;&gt;();</span><br>        <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">null</span>) &#123;<br>            que.add(root);<br>        &#125;<br><br>        <span class="hljs-keyword">while</span> (!que.isEmpty())&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> que.size(); <span class="hljs-comment">// 获取层数节点数</span><br>            <span class="hljs-comment">//保留每层的头节点</span><br>            <span class="hljs-type">Node</span> <span class="hljs-variable">levelhead</span> <span class="hljs-operator">=</span> que.poll();<br>            <span class="hljs-keyword">if</span> (levelhead.left != <span class="hljs-literal">null</span>)&#123;<br>                que.add(levelhead.left);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (levelhead.right != <span class="hljs-literal">null</span>)&#123;<br>                que.add(levelhead.right);<br>            &#125;<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> ; i &lt; size ; i++)&#123;<br>                <span class="hljs-type">Node</span> <span class="hljs-variable">levelnext</span> <span class="hljs-operator">=</span> que.poll();<br>                System.out.println(levelnext.val);<br>                <span class="hljs-keyword">if</span> (levelnext.left != <span class="hljs-literal">null</span>)&#123;<br>                    que.add(levelnext.left);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (levelnext.right != <span class="hljs-literal">null</span>)&#123;<br>                    que.add(levelnext.right);<br>                &#125;<br>                levelhead.next = levelnext;<br>                levelhead = levelnext;<br>            &#125;<br>            <span class="hljs-comment">// while (size &gt; 1)&#123;</span><br>                <br>            <span class="hljs-comment">//     size--;</span><br>            <span class="hljs-comment">// &#125;</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>515. 在每个树行中找最大值</title>
    <link href="/2022/11/28/515-%E5%9C%A8%E6%AF%8F%E4%B8%AA%E6%A0%91%E8%A1%8C%E4%B8%AD%E6%89%BE%E6%9C%80%E5%A4%A7%E5%80%BC/"/>
    <url>/2022/11/28/515-%E5%9C%A8%E6%AF%8F%E4%B8%AA%E6%A0%91%E8%A1%8C%E4%B8%AD%E6%89%BE%E6%9C%80%E5%A4%A7%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<h2 id="在每个树行中找最大值-链接">515. 在每个树行中找最大值-<ahref="https://leetcode.cn/problems/find-largest-value-in-each-tree-row/">链接🚀</a></h2><h3 id="题目">题目</h3><h3 id="题解">题解</h3><p>本题在原有的迭代法层序遍历节点的基础上，比较输出的叶子节点的值，并保留最大的那个，其实就是采用Math.max();方法比较叶子节点中的值。</p><h3 id="代码">代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">largestValues</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;Integer&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        Deque&lt;TreeNode&gt; que = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br><br>        que.addLast(root);<br><br>        <span class="hljs-keyword">while</span> (!que.isEmpty())&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> que.size();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE; <span class="hljs-comment">// 定义为能取到的最小值</span><br><br>            <span class="hljs-keyword">while</span> (size &gt; <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> que.pollFirst();<br>                max = Math.max(max , node.val);<br>                <span class="hljs-keyword">if</span> (node.left != <span class="hljs-literal">null</span>)&#123;<br>                    que.addLast(node.left);<br>                &#125;<br><br>                <span class="hljs-keyword">if</span> (node.right != <span class="hljs-literal">null</span>)&#123;<br>                    que.addLast(node.right);<br>                &#125;<br>                size--;<br>            &#125;<br>            result.add(max);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>429. N 叉树的层序遍历</title>
    <link href="/2022/11/28/429-N-%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <url>/2022/11/28/429-N-%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<h2 id="n-叉树的层序遍历-链接">429. N 叉树的层序遍历-<ahref="https://leetcode.cn/problems/n-ary-tree-level-order-traversal/">链接🚀</a></h2><h3 id="题目">题目</h3><h3 id="题解">题解</h3><p>在原有的迭代遍历二叉树的基础上，在遍历队列中每层的叶子节点时，应当判断该叶子的孩子节点是否为空，若不为空，我们应当将该叶子的孩子介节点入队中。</p><h3 id="代码">代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">// Definition for a Node.</span><br><span class="hljs-comment">class Node &#123;</span><br><span class="hljs-comment">    public int val;</span><br><span class="hljs-comment">    public List&lt;Node&gt; children;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    public Node() &#123;&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    public Node(int _val) &#123;</span><br><span class="hljs-comment">        val = _val;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    public Node(int _val, List&lt;Node&gt; _children) &#123;</span><br><span class="hljs-comment">        val = _val;</span><br><span class="hljs-comment">        children = _children;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">levelOrder</span><span class="hljs-params">(Node root)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(); <span class="hljs-comment">// 初始化一个二维数组</span><br>        Deque&lt;Node&gt; que = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(); <span class="hljs-comment">//初始化一个栈</span><br><br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br><br>        que.offerLast(root); <span class="hljs-comment">//节点入栈</span><br><br>        <span class="hljs-keyword">while</span> (!que.isEmpty())&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> que.size();<br>            List&lt;Integer&gt; levelnode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; size ; i++) &#123;<br>                <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> que.pollFirst();<br>                levelnode.add(node.val);<br><br>                List&lt;Node&gt; children = node.children;<br>                <span class="hljs-keyword">if</span> (children == <span class="hljs-literal">null</span> || children.size() == <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 当前节点的叶子节点为空或者叶子大小为0，则结束本次循环 直接看栈中剩余的节点</span><br>                &#125;<br><br>                <span class="hljs-keyword">for</span> (Node child : children) &#123;<br>                    <span class="hljs-keyword">if</span> (child != <span class="hljs-literal">null</span>)&#123;<br>                        que.addLast(child);<br>                    &#125;<br>                &#125;<br>            &#125;<br>            result.add(levelnode);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>637. 二叉树的层平均值</title>
    <link href="/2022/11/27/637-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%B9%B3%E5%9D%87%E5%80%BC/"/>
    <url>/2022/11/27/637-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%B9%B3%E5%9D%87%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<h2 id="二叉树的层平均值-链接">637. 二叉树的层平均值-<ahref="https://leetcode.cn/problems/average-of-levels-in-binary-tree/">链接🚀</a></h2><h3 id="题目">题目</h3><p>给定一个非空二叉树的根节点 root ,以数组的形式返回每一层节点的平均值。与实际答案相差 10-5以内的答案可以被接受。</p><h3 id="题解">题解</h3><p>初始化一个Double类型的变量，对每层的叶子节点的值累加，最后再将该累加值除以层节点个数</p><h3 id="代码">代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Double&gt; <span class="hljs-title function_">averageOfLevels</span><span class="hljs-params">(TreeNode root)</span> &#123;<br><br>        List&lt;Double&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        Deque&lt;TreeNode&gt; que = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br><br>        que.addFirst(root);<br><br>        <span class="hljs-keyword">while</span> (!que.isEmpty()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> que.size();<br>            <span class="hljs-comment">// TreeNode peek = que.peekFirst(); //返回头部</span><br>    <br>            <span class="hljs-type">Double</span> <span class="hljs-variable">levelnode</span> <span class="hljs-operator">=</span><span class="hljs-number">0.0</span>;<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; size ; i++)&#123;<br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> que.pollFirst();<br>                levelnode += node.val; <span class="hljs-comment">// 累加器</span><br>                System.out.println(node.val);<br><br>                <span class="hljs-keyword">if</span> (node.left != <span class="hljs-literal">null</span>)&#123;<br>                    que.addLast(node.left);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (node.right != <span class="hljs-literal">null</span>)&#123;<br>                    que.addLast(node.right);<br>                &#125;<br><br>            &#125;<br>            System.out.println(levelnode);<br>            result.add(levelnode / size );<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> result;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>199. 二叉树的右视图</title>
    <link href="/2022/11/27/199-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE/"/>
    <url>/2022/11/27/199-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="链接">[链接🚀]</h2><h3 id="题目">题目</h3><p>给定一个二叉树的 根节点root，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p><h3 id="题解">题解</h3><p>采用二叉树的层序遍历，利用迭代法输出二叉树的每层的节点，最后保存每层的最后一个节点。</p><h3 id="代码">代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">rightSideView</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;Integer&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(); <span class="hljs-comment">// 存放结果数组</span><br><br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>        Deque&lt;TreeNode&gt; que = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        que.offer(root);<br>        <span class="hljs-keyword">while</span> (!que.isEmpty())&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> que.size(); <span class="hljs-comment">// 记录每层节点个数</span><br>            <span class="hljs-comment">// System.out.println(size);</span><br>            <span class="hljs-keyword">for</span> ( <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; size ; i++)&#123;<br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> que.pollFirst();<br>                <span class="hljs-keyword">if</span> (node.right != <span class="hljs-literal">null</span>) &#123;<br>                    que.addFirst(node.right); <span class="hljs-comment">//右子树先入队</span><br>                &#125;<br>                <span class="hljs-keyword">if</span> (node.left != <span class="hljs-literal">null</span>) &#123;<br>                    que.addFirst(node.left);<br>                &#125;<br>                <span class="hljs-keyword">if</span> ( i == size - <span class="hljs-number">1</span>)&#123;<br>                    <span class="hljs-comment">// System.out.println(i);</span><br>                    result.add(node.val);<br>                &#125;<br><br>            &#125;<br><br><br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>构建二叉树-Java版</title>
    <link href="/2022/11/27/%E6%9E%84%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91-Java%E7%89%88/"/>
    <url>/2022/11/27/%E6%9E%84%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91-Java%E7%89%88/</url>
    
    <content type="html"><![CDATA[<h2 id="链接">[链接🚀]</h2><h3 id="创建二叉树步骤">创建二叉树步骤</h3><h4id="创建一个com.leetcode.binarytree包">创建一个com.leetcode.binarytree包</h4><h4 id="创建一个treenode.java文件">创建一个TreeNode.java文件</h4><h4id="构建类的属性-即就是节点的值节点的左子树节点的右子树">构建类的属性-即就是节点的值、节点的左子树、节点的右子树</h4><h4id="创建一个带有节点参数treenode的构造方法和一个包含右节点的值和左右子树的构造方法">创建一个带有节点参数TreeNode的构造方法和一个包含右节点的值和左右子树的构造方法</h4><h4id="定义公有的方法外部访问方法以获取左子树getlefttree和获取右子树getrighttree">定义公有的方法外部访问方法以获取左子树getLefttree()和获取右子树getRighttree()</h4><h4id="创建一个公有的方法以实现左右子树的创建既可以对单个子树的左子树和右子树分别创建又可以对两个子树同时创建">创建一个公有的方法以实现左右子树的创建，既可以对单个子树的左子树和右子树分别创建，又可以对两个子树同时创建</h4><h3 id="代码">代码</h3><p>详细的可以运行的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.leetcode.binarytree;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> val;<br>    <span class="hljs-keyword">private</span> TreeNode left;<br>    <span class="hljs-keyword">private</span> TreeNode right;<br>    <span class="hljs-comment">// 二叉树 无参构造器</span><br>    TreeNode() &#123;<br><br>    &#125;<br>    <span class="hljs-comment">// 二叉树 有参构造器</span><br>    TreeNode(<span class="hljs-type">int</span> val) &#123; <br>        <span class="hljs-built_in">this</span>.val = val; <br>    &#125;<br>    TreeNode(<span class="hljs-type">int</span> val, TreeNode left, TreeNode right) &#123;<br>        <span class="hljs-built_in">this</span>.val = val;<br>        <span class="hljs-built_in">this</span>.left = left;<br>        <span class="hljs-built_in">this</span>.right = right;<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> int return the val</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getVal</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> val;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> val the val to set</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setVal</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-built_in">this</span>.val = val;<br>    &#125;<br><br>    <span class="hljs-comment">//创建左子树</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">makeLeftTree</span><span class="hljs-params">(<span class="hljs-type">int</span> left)</span> &#123;<br>        <span class="hljs-built_in">this</span>.left = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(left);<br>    &#125;<br><br>    <span class="hljs-comment">//创建右子树</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">makeRightTree</span><span class="hljs-params">(<span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-built_in">this</span>.right = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(right);<br>    &#125;<br>    <br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">makesubtree</span> <span class="hljs-params">( <span class="hljs-type">int</span> left , <span class="hljs-type">int</span> right)</span>&#123;<br>        <span class="hljs-built_in">this</span>.left = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(left);<br>        <span class="hljs-built_in">this</span>.right = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(right);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">getLefttree</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">getRightree</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> right;<br>    &#125;<br><br>    <span class="hljs-comment">//中序遍历</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">inorderTraversal</span> <span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">this</span>.left != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-built_in">this</span>.left.inorderTraversal();<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;[&quot;</span> + <span class="hljs-built_in">this</span>.val + <span class="hljs-string">&quot;]&quot;</span>);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.right != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-built_in">this</span>.right.inorderTraversal();<br>        &#125;<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>107. 二叉树的层序遍历 II</title>
    <link href="/2022/11/27/107-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86-II/"/>
    <url>/2022/11/27/107-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86-II/</url>
    
    <content type="html"><![CDATA[<h2 id="二叉树的层序遍历-ii-链接">107. 二叉树的层序遍历 II-<ahref="https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/">链接🚀</a></h2><h3 id="题目">题目</h3><h3 id="题解">题解</h3><p>通过102题的思路得到从上往下的二维数组后，我们通数组反转将结果中的数组逆向输出</p><h3 id="代码">代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">levelOrderBottom</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-comment">// levelOrderBottomRecursion(root , 0); //递归做不出来</span><br>        levelOrderBottomIterate(root);<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">levelOrderBottomIterate</span><span class="hljs-params">(TreeNode node)</span> &#123;<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br><br>        Deque&lt;TreeNode&gt; que = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(); <span class="hljs-comment">//初始化一个队列</span><br><br>        que.offer(node); <span class="hljs-comment">// root node into que</span><br><br>        List&lt;List&lt;Integer&gt;&gt; resulttmp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();<br>        <span class="hljs-keyword">while</span> (!que.isEmpty())&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> que.size();<br>            List&lt;Integer&gt; levelnode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            <span class="hljs-keyword">while</span> (size &gt; <span class="hljs-number">0</span>) &#123;<br>                 <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> que.poll();<br>                 levelnode.add(root.val);<br>                 <span class="hljs-keyword">if</span> (root.left != <span class="hljs-literal">null</span>) &#123;<br>                     que.offer(root.left);<br>                 &#125;<br>                 <span class="hljs-keyword">if</span> (root.right != <span class="hljs-literal">null</span>) &#123;<br>                     que.offer(root.right);<br>                 &#125;<br>                 size--;<br>            &#125;<br>            resulttmp.add(levelnode);<br>        &#125;<br>        System.out.println(resulttmp);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> resulttmp.size() -<span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span> ; i--)&#123;<br>            result.add(resulttmp.get(i));<br>        &#125;<br>        System.out.println(result);<br>    &#125; <br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">levelOrderBottomRecursion</span><span class="hljs-params">(TreeNode root , <span class="hljs-type">int</span> deepth)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        deepth++;<br><br>        <span class="hljs-keyword">if</span> (result.size() &lt; deepth) &#123;<br>            List&lt;Integer&gt; levelnode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            result.add(levelnode);<br>        &#125;<br>        result.get(deepth - <span class="hljs-number">1</span>).add(root.val);<br>        levelOrderBottomRecursion(root.right , deepth);<br>        levelOrderBottomRecursion(root.left , deepth);<br><br>        System.out.println(result);<br><br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> result.size() - <span class="hljs-number">1</span> ; i &gt;=<span class="hljs-number">0</span> ; i--)&#123;<br>            res.add(result.get(i));<br>        &#125;<br><br><br>        result.clear();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; res.size() ; i++) &#123;<br>            result.add(res.get(i));<br>        &#125;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>102. 二叉树的层序遍历</title>
    <link href="/2022/11/25/102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <url>/2022/11/25/102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<h2 id="二叉树的层序遍历-链接">102. 二叉树的层序遍历-<ahref="https://leetcode.cn/problems/binary-tree-level-order-traversal/">链接🚀</a></h2><h3 id="题目">题目</h3><p>给你二叉树的根节点 root ，返回其节点值的 层序遍历 。（即逐层地，从左到右访问所有节点）。</p><h3 id="题解">题解</h3><p>1<a href="/img/md/leetcode/102leetcode.jpg">ti</a></p><h3 id="代码">代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;(); <span class="hljs-comment">// 初始化一个二维数组，这是一个成员属性</span><br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">levelOrder</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-comment">// levelOrderIterate(root);</span><br>        levelOrderRecursion(root , <span class="hljs-number">0</span>);<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">levelOrderRecursion</span><span class="hljs-params">(TreeNode root , <span class="hljs-type">int</span> deepth)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        deepth++; <br><br>        <span class="hljs-keyword">if</span> (result.size() &lt; deepth) &#123;<span class="hljs-comment">// 用于控制深度，深度保持一个平衡，若深度与二维数组大小不一致时，我们就新创建一个一维数组，用于存储新的一层的所有节点</span><br>            List&lt;Integer&gt; levelnode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;(); <span class="hljs-comment">//</span><br>            result.add(levelnode);<br>        &#125;<br>        result.get(deepth - <span class="hljs-number">1</span>).add(root.val);<br><br>        levelOrderRecursion(root.left , deepth);<br>        levelOrderRecursion(root.right , deepth);<br>    &#125;<br><br>    <span class="hljs-comment">// iterate answer</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">levelOrderIterate</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        Queue&lt;TreeNode&gt; que = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;TreeNode&gt;(); <span class="hljs-comment">//初始化一个存放二叉树节点的队列</span><br>        que.offer(root); <span class="hljs-comment">// 放入根节点</span><br><br>        <span class="hljs-keyword">while</span> (!que.isEmpty()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> que.size(); <span class="hljs-comment">// 记录存放在栈中每层二叉树节点的个数</span><br>            List&lt;Integer&gt; levelnode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;(); <span class="hljs-comment">//定义一个一维数组，用于记录每层的节点数</span><br><br>            <span class="hljs-keyword">while</span> (size &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> que.poll(); <span class="hljs-comment">//弹出节点</span><br>                levelnode.add(node.val); <span class="hljs-comment">//保存节点</span><br><br>                <span class="hljs-keyword">if</span> (node.left != <span class="hljs-literal">null</span>) &#123;<br>                    que.offer(node.left);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (node.right != <span class="hljs-literal">null</span>) &#123;<br>                    que.offer(node.right);<br>                &#125;<br>                size--;<br>            &#125;<br>            result.add(levelnode);<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>94. 二叉树的中序遍历</title>
    <link href="/2022/11/24/94-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <url>/2022/11/24/94-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<h2 id="二叉树的中序遍历-链接">94. 二叉树的中序遍历-<ahref="https://leetcode.cn/problems/binary-tree-inorder-traversal/">链接🚀</a></h2><h3 id="题目">题目</h3><h3 id="题解">题解</h3><h3 id="代码">代码</h3><p>与二叉树的前序遍历和后序遍历 所采用的递归思路一致;</p><p>迭代法思路：</p><p>定义一个指针从根节点遍历到最左的叶子节点，然后保存该节点后，再让该指针指向右孩子节点；</p><h4 id="递归法">递归法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;Integer&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>        inorder(root , result);<br>        <span class="hljs-keyword">return</span> result;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">inorder</span><span class="hljs-params">(TreeNode root , List result)</span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <span class="hljs-comment">// LNR （左、中、右）</span><br>        inorder(root.left , result);<br>        result.add(root.val);<br>        inorder(root.right , result);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="迭代法">迭代法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;Integer&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br><br>        Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> root;<br><br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span> || !stack.isEmpty())&#123;<br>            <span class="hljs-keyword">if</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>                stack.push(cur);<br>                cur = cur.left; <span class="hljs-comment">//该指针遍历左孩子</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> stack.pop();<br>                result.add(node.val);<br>                cur = node.right; <span class="hljs-comment">// 该指针遍历右孩子</span><br>            &#125;<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>145. 二叉树的后序遍历</title>
    <link href="/2022/11/24/145-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <url>/2022/11/24/145-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<h2 id="二叉树的后序遍历-链接">145. 二叉树的后序遍历-<ahref="https://leetcode.cn/problems/binary-tree-postorder-traversal/">链接🚀</a></h2><h3 id="题目">题目</h3><h3 id="题解">题解</h3><p>与上一题类似</p><p>迭代法思路：</p><p>与前序遍历方法类似，先根节点入栈，然后出栈，然后再让根节点的左孩子入栈后，右孩子再入栈，最后出栈的结果就保证为N、R、L。最后再利用集合里面的reverse函数反转。</p><h3 id="代码">代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">postorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;Integer&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>        postorder(root , result);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span>  <span class="hljs-title function_">postorder</span><span class="hljs-params">(TreeNode root , List result)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// LR (后序遍历，左、右、根)：也就是最后访问根结点</span><br>        postorder(root.left , result);<br>        postorder(root.right , result);<br>        result.add(root.val);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="迭代法">迭代法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">postorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;Integer&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br><br>        Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        stack.push(root);<br><br>        <span class="hljs-keyword">while</span> (!stack.isEmpty()) &#123;<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> stack.pop();<br>            result.add(node.val);<br><br>            <span class="hljs-keyword">if</span> (node.left != <span class="hljs-literal">null</span>)&#123;<br>                stack.push(node.left);<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (node.right != <span class="hljs-literal">null</span>)&#123;<br>                stack.push(node.right);<br>            &#125;<br>        &#125;<br><br>        Collections.reverse(result);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>144. 二叉树的前序遍历</title>
    <link href="/2022/11/24/144-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <url>/2022/11/24/144-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<h2 id="二叉树的前序遍历-链接">144. 二叉树的前序遍历-<ahref="https://leetcode.cn/problems/binary-tree-preorder-traversal/">链接🚀</a></h2><h3 id="题目">题目</h3><h3 id="题解">题解</h3><p>递归的方式：确定递归的返回类型，递归的终止条件</p><p>采用迭代法的思路是：</p><ol type="1"><li>利用栈存储根节点，然后再存根节点的右孩子，再存根节点的左孩子。前提都是栈不为空。</li></ol><h3 id="代码">代码</h3><h4 id="递归法">递归法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span> 采用递归的方法<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">preorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;Integer&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<span class="hljs-comment">//</span><br>        preorder(root , result);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">preorder</span><span class="hljs-params">(TreeNode root , List&lt;Integer&gt; result)</span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        result.add(root.val); <span class="hljs-comment">//将根节点放入结果链表中</span><br>        preorder(root.left , result); <span class="hljs-comment">//遍历二叉树的左孩子</span><br>        preorder(root.right , result); <span class="hljs-comment">//遍历二叉树的右孩子</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="迭代法">迭代法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">preorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;Integer&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>        Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        stack.push(root);<br><br>        <span class="hljs-keyword">while</span> (!stack.isEmpty()) &#123;<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> stack.pop(); <span class="hljs-comment">//出栈元素为一个二叉树类型的节点，应当由二叉树类型的节点接收；</span><br>            result.add(node.val);<br><br>            <span class="hljs-keyword">if</span> (node.right != <span class="hljs-literal">null</span>) &#123;<br>                stack.push(node.right);<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (node.left != <span class="hljs-literal">null</span>) &#123;<br>                stack.push(node.left);<br>            &#125;<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>参数列表的值传递与引用传递</title>
    <link href="/2022/11/24/%E5%8F%82%E6%95%B0%E5%88%97%E8%A1%A8%E7%9A%84%E5%80%BC%E4%BC%A0%E9%80%92%E4%B8%8E%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/"/>
    <url>/2022/11/24/%E5%8F%82%E6%95%B0%E5%88%97%E8%A1%A8%E7%9A%84%E5%80%BC%E4%BC%A0%E9%80%92%E4%B8%8E%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/</url>
    
    <content type="html"><![CDATA[<h3 id="值传递与引用传递">值传递与引用传递</h3><h5id="基本数据类型的值传递其形参不影响实参">基本数据类型的值传递，其形参不影响实参</h5><h5id="引用类型传递其形参影响实参而java中形参的引用为地址">引用类型传递，其形参影响实参，而java中，形参的引用为地址</h5>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>类与对象</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>347. 前 K 个高频元素</title>
    <link href="/2022/11/23/347-%E5%89%8D-K-%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0/"/>
    <url>/2022/11/23/347-%E5%89%8D-K-%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="前-k-个高频元素-链接">347. 前 K 个高频元素-<ahref="https://leetcode.cn/problems/top-k-frequent-elements/">链接🚀</a></h2><h3 id="题目">题目</h3><p>给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k高的元素。你可以按 任意顺序 返回答案。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">输入: nums = [1,1,1,2,2,3], k = 2<br>输出: [1,2]<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">输入: nums = [1], k = 1<br>输出: [1]<br></code></pre></td></tr></table></figure><h3 id="题解">题解</h3><p>针对本题，对于数组，我们定义一个map结构来统计元素及其出现的次数。存储为&lt;key , value&gt; key 为元素 ，value为出现的次数然后再初始化一个存储元素和次数的优先级队列，也就是小根堆，将元素出现次数最小的放到小根堆的堆顶。最后遍历map，依次比较当前map中的元素与堆顶元素次数，若当前map中的元素出现的次数大于堆顶元素出现的次数，那么将堆顶元素输出。</p><h3 id="代码">代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] topKFrequent(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k) &#123;<br>        Map&lt;Integer , Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(); <span class="hljs-comment">//初始化一个哈希表</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums)&#123;<br>            map.put(num , map.getOrDefault(num , <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>); <span class="hljs-comment">//放入元素</span><br>        &#125;<br><br>        PriorityQueue&lt;<span class="hljs-type">int</span>[]&gt; prique = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;((pair1 , pair2)-&gt;pair1[<span class="hljs-number">1</span>]-pair2[<span class="hljs-number">1</span>]); <span class="hljs-comment">// 初始化一个优先级队列</span><br>        <span class="hljs-comment">//构建小根堆，将维护k个元素出现频率次数较小的value在堆顶</span><br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;Integer , Integer&gt; entry : map.entrySet())&#123;<br>            <span class="hljs-keyword">if</span> (prique.size() &lt; k)&#123;<br>                prique.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;entry.getKey() , entry.getValue()&#125;);<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (entry.getValue() &gt; prique.peek()[<span class="hljs-number">1</span>])&#123;<br>                    prique.poll(); <span class="hljs-comment">//小根堆的堆顶元素出队</span><br>                    prique.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;entry.getKey() , entry.getValue()&#125;);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[k];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> k-<span class="hljs-number">1</span> ; i &gt;= <span class="hljs-number">0</span> ; i--)&#123;<br>            res[i] = prique.poll()[<span class="hljs-number">0</span>];<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>栈/队列</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>239. 滑动窗口最大值</title>
    <link href="/2022/11/22/239-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC/"/>
    <url>/2022/11/22/239-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<h2 id="滑动窗口最大值-链接">239. 滑动窗口最大值-<ahref="https://leetcode.cn/problems/sliding-window-maximum/">链接🚀</a></h2><h3 id="题目">题目</h3><p>给你一个整数数组nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的k 个数字。滑动窗口每次只向右移动一位。</p><p>返回 滑动窗口中的最大值 。</p><p>example:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br>输入：nums = [1,3,-1,-3,5,3,6,7], k = 3<br>输出：[3,3,5,5,6,7]<br>解释：<br>滑动窗口的位置                最大值<br>---------------               -----<br>[1  3  -1] -3  5  3  6  7       3<br> 1 [3  -1  -3] 5  3  6  7       3<br> 1  3 [-1  -3  5] 3  6  7       5<br> 1  3  -1 [-3  5  3] 6  7       5<br> 1  3  -1  -3 [5  3  6] 7       6<br> 1  3  -1  -3  5 [3  6  7]      7<br><br></code></pre></td></tr></table></figure><h3 id="题解">题解</h3><p>题目要求输出滑动窗口中的最大值，本题采用队列进行解答。即就是构造一个单调队列，保证队列出口处的值始终为最大值。</p><p>为此我们需要保证两个前提条件： 1.入队时，若入队元素大于入口处的元素，我们应该将入口处的元素弹出，入口处元素获取方法利用getLast函数，移除此入口处元素方法为removeLast。2.出队时，若出队元素等于出队的元素，即就是要将该窗口中的最大值出队，此时应该采用poll函数出队，查看队顶的方法为peek函数。</p><p>注意本题的边界条件</p><p>数组长度为1时应当输出当前数组。</p><p>最后每取一个队顶元素，应当将此队顶元素放入数组中并且数组的下标自加1</p><h3 id="代码">代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] maxSlidingWindow(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k) &#123;<br>        <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> nums;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> nums.length - k + <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[len]; <span class="hljs-comment">//存放结果的数组</span><br>        <span class="hljs-type">int</span>  <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-type">Quque</span> <span class="hljs-variable">que</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Quque</span>();<br>        <span class="hljs-keyword">for</span> ( <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k ; i++)&#123; <span class="hljs-comment">//将数组的前k个元素加入队列</span><br>            que.add(nums[i]);<br>        &#125;<br>        res[num++] = que.peek(); <span class="hljs-comment">//取出此窗口中最大的元素</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> k; i &lt; nums.length ; i++ )&#123;<br>            que.poll(nums[i -k]); <span class="hljs-comment">//</span><br>            que.add(nums[i]);<br>            res[num++] = que.peek(); <span class="hljs-comment">// 记录每个窗口的最大值</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//构造一个单调队列</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Quque</span> &#123;<br>    Deque&lt;Integer&gt; que = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(); <span class="hljs-comment">//初始化一个队列</span><br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">poll</span> <span class="hljs-params">(<span class="hljs-type">int</span> value)</span>&#123;<br>        <span class="hljs-keyword">if</span> (!que.isEmpty() &amp;&amp; value == que.peek())&#123;<br>            que.poll();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span> <span class="hljs-params">(<span class="hljs-type">int</span> value)</span>&#123;<br>        <span class="hljs-keyword">while</span> (!que.isEmpty() &amp;&amp; value &gt; que.getLast())&#123;<br>            que.removeLast();<br>        &#125;<br>        que.add(value);<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">peek</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> que.peek();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>栈/队列</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>150. 逆波兰表达式求值</title>
    <link href="/2022/11/22/150-%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/"/>
    <url>/2022/11/22/150-%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<h2 id="逆波兰表达式求值-链接">150. 逆波兰表达式求值-<ahref="https://leetcode.cn/problems/evaluate-reverse-polish-notation/">链接🚀</a></h2><h3 id="题目">题目</h3><p>有效的算符包括 +、-、*、/ 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。</p><p>注意 两个整数之间的除法只保留整数部分。</p><p>可以保证给定的逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为0 的情况。</p><h3 id="题解">题解</h3><p>利用后缀表达式，可以让计算机无歧义的顺序执行该程序。</p><p>先判断运算符（这里需要用到equals()判断），再弹出两个栈顶元素运算后入栈</p><h3 id="代码">代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">evalRPN</span><span class="hljs-params">(String[] tokens)</span> &#123;<br>        Deque&lt;Integer&gt; deque = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>();<br>        <span class="hljs-keyword">for</span> (String s : tokens)&#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;+&quot;</span>.equals(s))&#123;<br>                deque.push(deque.pop() + deque.pop());<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;-&quot;</span>.equals(s))&#123;<br>                deque.push(-deque.pop() + deque.pop());<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;*&quot;</span>.equals(s))&#123;<br>                deque.push(deque.pop() * deque.pop());<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;/&quot;</span>.equals(s))&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">tempp1</span> <span class="hljs-operator">=</span> deque.pop();<br>                <span class="hljs-type">int</span> <span class="hljs-variable">tempp2</span> <span class="hljs-operator">=</span> deque.pop();<br>                deque.push(tempp2/tempp1);<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                deque.push(Integer.valueOf(s));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> deque.pop();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>栈/队列</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>1047. 删除字符串中的所有相邻重复项</title>
    <link href="/2022/11/22/1047-%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9/"/>
    <url>/2022/11/22/1047-%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9/</url>
    
    <content type="html"><![CDATA[<h2 id="删除字符串中的所有相邻重复项-链接">1047.删除字符串中的所有相邻重复项-<ahref="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/">链接🚀</a></h2><h3 id="题目">题目</h3><p>给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。</p><p>在 S 上反复执行重复项删除操作，直到无法继续删除。</p><p>在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。</p><h3 id="题解">题解</h3><p>利用栈，当栈为空或者栈顶元素和当前不相等时就入栈，否则就出栈</p><p>最后将栈内元素出栈就得到想要的字符串啦！</p><h3 id="代码">代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">removeDuplicates</span><span class="hljs-params">(String s)</span> &#123;<br>        ArrayDeque&lt;Character&gt; deque = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;(); <span class="hljs-comment">//初始化一个栈</span><br>        <span class="hljs-type">char</span> ch;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; s.length() ; i++)&#123;<br>            ch = s.charAt(i); <br>            <span class="hljs-keyword">if</span> (deque.isEmpty() || deque.peek() != ch)&#123;<br>                deque.push(ch);<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                deque.pop();<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span>  <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">while</span> (!deque.isEmpty())&#123;<br>            str = deque.pop() + str;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> str;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>栈/队列</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>有效的括号</title>
    <link href="/2022/11/22/%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/"/>
    <url>/2022/11/22/%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/</url>
    
    <content type="html"><![CDATA[<h2 id="有效的括号--leetcode-20链接">有效的括号--leetcode-20<ahref="https://leetcode.cn/problems/valid-parentheses/">链接🚀</a></h2><h3 id="题目">题目</h3><p>给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s，判断字符串是否有效。</p><p>有效字符串需满足：</p><p>左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。每个右括号都有一个对应的相同类型的左括号。</p><h3 id="题解">题解</h3><p>本题利用栈作为数据结构来解决问题是非常好的，我们需要考虑以下几种情况。<br />1. 当栈空时 字符串并为遍历结束 2. 栈顶元素与字符串元素不相等 3.已经遍历完所有的元素，但是栈不为空</p><h3 id="代码">代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(String s)</span> &#123;<br>        Deque&lt;Character&gt; que =<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(); <span class="hljs-comment">// 初始化一个栈</span><br>        <span class="hljs-type">char</span> ch; <span class="hljs-comment">// </span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; s.length() ; i++)&#123;<br>            ch = s.charAt(i); <span class="hljs-comment">// 遍历取值s中的字符</span><br>            <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;(&#x27;</span>)&#123;<br>                que.push(<span class="hljs-string">&#x27;)&#x27;</span>);<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;[&#x27;</span>)&#123;<br>                que.push(<span class="hljs-string">&#x27;]&#x27;</span>);<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;&#123;&#x27;</span>)&#123;<br>                que.push(<span class="hljs-string">&#x27;&#125;&#x27;</span>);<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( que.isEmpty() || que.peek() != ch )&#123; <span class="hljs-comment">// que.isEmpty()判断应该在取栈顶元素操作前面 因为很可能为栈空 导致取栈顶元素时为空</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                que.pop();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> que.isEmpty(); <span class="hljs-comment">// 栈内元素是否为空 ， 若为空则</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>栈/队列</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>用队列实现栈-Java版</title>
    <link href="/2022/11/19/%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88-Java%E7%89%88/"/>
    <url>/2022/11/19/%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88-Java%E7%89%88/</url>
    
    <content type="html"><![CDATA[<h2 id="用栈来实现队列--leetcode-225链接">用栈来实现队列--leetcode-225<ahref="https://leetcode.cn/problems/implement-stack-using-queues/">链接🚀</a></h2><h3 id="题目">题目</h3><p>请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop和 empty）。</p><p>实现 MyStack 类：</p><p>void push(int x) 将元素 x 压入栈顶。<br />int pop() 移除并返回栈顶元素。<br />int top() 返回栈顶元素。<br />boolean empty() 如果栈是空的，返回 true ；否则，返回 false 。<br />注意：</p><p>你只能使用队列的基本操作 —— 也就是 push to back、peek/pop fromfront、size 和 is empty 这些操作。<br />你所使用的语言也许不支持队列。 你可以使用 list （列表）或者deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。</p><h3 id="题解">题解</h3><p>当在队列中取完一个元素之后就将该元素放到队列的末尾后，再利用pollfirst方法取元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStack</span> &#123;<br><br>    Deque&lt;Integer&gt; que1;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyStack</span><span class="hljs-params">()</span> &#123;<br>        que1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        que1.addLast(x);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> que1.size();<br>        size--;<br>        <span class="hljs-keyword">while</span> (size-- &gt; <span class="hljs-number">0</span>)&#123;<br>            que1.addLast(que1.peekFirst());<br>            que1.pollFirst();<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> que1.pollFirst();<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">top</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> que1.peekLast();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">empty</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> que1.isEmpty();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MyStack object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MyStack obj = new MyStack();</span><br><span class="hljs-comment"> * obj.push(x);</span><br><span class="hljs-comment"> * int param_2 = obj.pop();</span><br><span class="hljs-comment"> * int param_3 = obj.top();</span><br><span class="hljs-comment"> * boolean param_4 = obj.empty();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>栈/队列</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>用栈来实现队列-Java版</title>
    <link href="/2022/11/19/%E7%94%A8%E6%A0%88%E6%9D%A5%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97-Java%E7%89%88/"/>
    <url>/2022/11/19/%E7%94%A8%E6%A0%88%E6%9D%A5%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97-Java%E7%89%88/</url>
    
    <content type="html"><![CDATA[<h2 id="用栈来实现队列--leetcode-232链接">用栈来实现队列--leetcode-232<ahref="https://leetcode.cn/problems/implement-queue-using-stacks/">链接🚀</a></h2><h3 id="题目">题目</h3><p>请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：</p><p>实现 MyQueue 类：</p><p>void push(int x) 将元素 x 推到队列的末尾<br />int pop() 从队列的开头移除并返回元素<br />int peek() 返回队列开头的元素<br />boolean empty() 如果队列为空，返回 true ；否则，返回 false<br />说明：</p><p>你 只能 使用标准的栈操作 —— 也就是只有 push to top, peek/pop fromtop, size, 和 is empty 操作是合法的。<br />你所使用的语言也许不支持栈。你可以使用 list 或者deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。</p><h3 id="题解">题解</h3><p>声明两个栈，一个负责元素入栈，另外一个负责元素出栈；<br />其中需要写明一个函数用以判断负责出栈的栈是否为空，若为空，且入栈的栈的元素不为空，则将入栈里面的所有元素都<br />将其放入栈内。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyQueue</span> &#123;<br><br>    Stack&lt;Integer&gt; stackIn;<br>    Stack&lt;Integer&gt; stackOut;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyQueue</span><span class="hljs-params">()</span> &#123;<br>        stackIn = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        stackOut = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        stackIn.push(x);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">// 栈出的时候 需要保证负责栈出中的元素不为空</span><br>        dumpstack();<br>        <span class="hljs-keyword">return</span> stackOut.pop();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">peek</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">//取栈顶元素 需要保证负责栈出中的元素不为空</span><br>        dumpstack();<br>        <span class="hljs-keyword">return</span> stackOut.peek();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">empty</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> stackIn.empty() &amp;&amp; stackOut.empty(); <span class="hljs-comment">//只有栈入元素和栈出中元素同时为空 才能判断队列为空</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dumpstack</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span> (!stackOut.isEmpty()) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 判断栈出中元素不为空 若为空 按照顺序执行 进入下一步 while循环中 判断栈入元素是否为空</span><br>        <span class="hljs-keyword">while</span> (!stackIn.isEmpty())&#123; <span class="hljs-comment">// 将stackIn中的所有元素都放入stackOut中 此步保证栈出元素不为空</span><br>            stackOut.push(stackIn.pop());<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MyQueue object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MyQueue obj = new MyQueue();</span><br><span class="hljs-comment"> * obj.push(x);</span><br><span class="hljs-comment"> * int param_2 = obj.pop();</span><br><span class="hljs-comment"> * int param_3 = obj.peek();</span><br><span class="hljs-comment"> * boolean param_4 = obj.empty();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>栈/队列</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>反转字符串里面的单词--leetcode-151</title>
    <link href="/2022/11/13/%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E9%9D%A2%E7%9A%84%E5%8D%95%E8%AF%8D/"/>
    <url>/2022/11/13/%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E9%9D%A2%E7%9A%84%E5%8D%95%E8%AF%8D/</url>
    
    <content type="html"><![CDATA[<h2id="反转字符串里面的单词--leetcode-151链接">反转字符串里面的单词--leetcode-151<ahref="https://leetcode.cn/problems/reverse-words-in-a-string/">链接🚀</a></h2><h3 id="题目">题目</h3><p>给你一个字符串 s ，请你反转字符串中 单词 的顺序。 单词是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词分隔开。 返回 单词 顺序颠倒且 单词 之间用单个空格连接的结果字符串。来源：力扣（LeetCode）链接：https://leetcode.cn/problems/reverse-words-in-a-string</p><h3 id="题解">题解</h3><p>一、将字符串中多余的空格清除掉，利用双指针法，当快指针的值不为空时将该值赋值给慢指针注意 慢指针用来控制单词间的空格 二、利用reverse库函数反转整个链表三、利用for里面判断当i的指向为最后一个元素或者为空时我们应当反转此时的单词注意++i</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">removeextraspace</span><span class="hljs-params">(string&amp; s)</span></span>&#123;<br>        <span class="hljs-type">int</span> slow = <span class="hljs-number">0</span>; <span class="hljs-comment">//定义慢指针</span><br>        <span class="hljs-keyword">for</span> ( <span class="hljs-type">int</span> fast = <span class="hljs-number">0</span> ; fast &lt; s.<span class="hljs-built_in">size</span>(); ++fast)&#123;<br>            <span class="hljs-keyword">if</span> (s[fast] != <span class="hljs-string">&#x27; &#x27;</span>)&#123;<br>                <span class="hljs-keyword">if</span> (slow != <span class="hljs-number">0</span> )&#123;<br>                    s[slow++] = <span class="hljs-string">&#x27; &#x27;</span>; <span class="hljs-comment">//手动设置为空值</span><br>                    <span class="hljs-comment">// slow++;</span><br>                &#125;<br>                <span class="hljs-keyword">while</span> (fast &lt; s.<span class="hljs-built_in">size</span>() &amp;&amp; s[fast] != <span class="hljs-string">&#x27; &#x27;</span>)&#123;<br>                    s[slow++] = s[fast++];<br>                    <span class="hljs-comment">// fast++;</span><br>                    <span class="hljs-comment">// slow++;</span><br>                &#125;<br>            &#125;<br>        &#125;<br>        s.<span class="hljs-built_in">resize</span>(slow); <span class="hljs-comment">// 重新设置删除多余空格后的数组大小</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reverse</span><span class="hljs-params">(string&amp; s ,<span class="hljs-type">int</span> start ,<span class="hljs-type">int</span> end)</span></span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = start ,j = end ; i &lt; j ; i++ ,j--)&#123;<br>            <span class="hljs-built_in">swap</span>(s[i] , s[j]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function">string <span class="hljs-title">reverseWords</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-built_in">removeextraspace</span>(s); <span class="hljs-comment">// 去除多余的空格</span><br>        <span class="hljs-built_in">reverse</span>(s , <span class="hljs-number">0</span> , s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> start = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ;  i &lt;= s.<span class="hljs-built_in">size</span>() ; ++i)&#123;<br>            <span class="hljs-keyword">if</span> (i == s.<span class="hljs-built_in">size</span>() || s[i] == <span class="hljs-string">&#x27; &#x27;</span>)&#123;<br>                <span class="hljs-built_in">reverse</span>(s , start , i - <span class="hljs-number">1</span>);<br>                start = i + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>字符串</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>螺旋矩阵Ⅱ-leetcode-59</title>
    <link href="/2022/08/20/%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5-leetcode-59/"/>
    <url>/2022/08/20/%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5-leetcode-59/</url>
    
    <content type="html"><![CDATA[<h2 id="螺旋矩阵ⅱ59题链接">螺旋矩阵Ⅱ59题<ahref="https://leetcode.cn/problems/spiral-matrix-ii/">链接🚀</a></h2><p>题解：</p><p>c++代码思路：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 给出的数字n是奇数还是偶数，</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br>A当给出的数字n是偶数时：<br><span class="hljs-number">1.</span>直接判断需要循环n/次，<span class="hljs-keyword">while</span>循环每次循环减一，相应的往中心更靠近。<br><span class="hljs-number">2.</span>数组矩阵肯定有四条边，因此需要四个<span class="hljs-keyword">for</span>循环依次给每条边赋值，利用循环不变量；<br>B当给出的数字n为奇数时：<br><span class="hljs-number">1.</span>只需要循环完n/<span class="hljs-number">2</span>次之后，把最后累加的count值赋值给最中心的那个元素<br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">generateMatrix</span>(<span class="hljs-type">int</span> n) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">ans</span>(n , <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n , <span class="hljs-number">0</span>)); <span class="hljs-comment">//定义一个二维数组</span><br>        <span class="hljs-type">int</span> col = <span class="hljs-number">0</span>; <span class="hljs-comment">//定义行</span><br>        <span class="hljs-type">int</span> cul = <span class="hljs-number">0</span>; <span class="hljs-comment">//定义列</span><br>        <span class="hljs-type">int</span> count = <span class="hljs-number">1</span>; <span class="hljs-comment">//定义计数器，数组从1开始计数</span><br>        <span class="hljs-type">int</span> offset = <span class="hljs-number">1</span>; <span class="hljs-comment">//定义偏置</span><br>        <span class="hljs-type">int</span> i,j;<br>        <span class="hljs-type">int</span> middle = n/<span class="hljs-number">2</span>;       <span class="hljs-comment">// 控制最中间的位置</span><br>        <span class="hljs-type">int</span> loop = n/<span class="hljs-number">2</span>;     <span class="hljs-comment">// 控制循环次数</span><br>        <span class="hljs-keyword">while</span>(loop--)&#123; <span class="hljs-comment">// 判断循环多少圈</span><br>            <span class="hljs-keyword">for</span>( j = cul ; j &lt; n - offset ; j++)&#123; <span class="hljs-comment">// j 累加到该行的次大值</span><br>                ans[col][j] = count; <span class="hljs-comment">//赋值</span><br>                count++;<br>            &#125;<br>            <span class="hljs-keyword">for</span>( i = col ; i &lt; n - offset ; i++)&#123;   <span class="hljs-comment">//左闭右开区间</span><br>                ans[i][j] = count;<br>                count++;<br>            &#125;<br>            <span class="hljs-keyword">for</span>(;j &gt; cul ; j--)&#123;        <span class="hljs-comment">// 左闭右开</span><br>                ans[i][j] = count;  <br>                count++;<br>            &#125;<br>            <span class="hljs-keyword">for</span>(;i &gt; col ; i--)&#123;    <span class="hljs-comment">//左闭右开区间</span><br>                ans[i][j] = count;<br>                count++;<br>            &#125;<br>            col++;<br>            cul++;<br>            offset++;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(n%<span class="hljs-number">2</span>)&#123;<br>            ans[middle][middle] = count;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>数组</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>长度最小的子数组-leetcode-209</title>
    <link href="/2022/08/19/%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84-leetcode-209/"/>
    <url>/2022/08/19/%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84-leetcode-209/</url>
    
    <content type="html"><![CDATA[<h2 id="长度最小的子数组209题链接">长度最小的子数组209题<ahref="https://leetcode.cn/problems/minimum-size-subarray-sum/">链接🚀</a></h2><p>暴力解法的思路：利用两个for循环一个控制起始位置，另外一个控制终止位置。通过不断地将起始位置和终止位置之间所对应的数组值相加后，再与target值比较。若大于target式则记录下此时起始位置和终止位置的子序列长度即就是差值<strong>数组从0开始计数，最后差需要加上1</strong>。将这个子序列长度不断地与result进行比较，保留其中最小的那个值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 暴力解法</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-type">int</span> target, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> result = INT32_MAX; <span class="hljs-comment">//用于存最后的结果</span><br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>; <span class="hljs-comment">//用于记录所有临时子区间的和, 也就是所有子序列的和</span><br>        <span class="hljs-type">int</span> sublength = <span class="hljs-number">0</span>; <span class="hljs-comment">//用于记录子序列的值</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i; j &lt; nums.<span class="hljs-built_in">size</span>() ; j++)&#123;<br>                sum += nums[j]; <span class="hljs-comment">//将所有的j与i区间的值相加与taget目标做对比</span><br>                <span class="hljs-keyword">if</span>(sum &gt;= target)&#123;<br>                    sublength = j - i + <span class="hljs-number">1</span>; <span class="hljs-comment">//数组的下标是从零开始的</span><br>                    result = result &lt; sublength ? result : sublength;   <span class="hljs-comment">//核心 将所有大于target的所有子区间的下标累加起来逐一比较</span><br>                    <span class="hljs-keyword">break</span>; <span class="hljs-comment">//找到就将退出循环</span><br>                &#125;<br>            &#125;<br>            sum = <span class="hljs-number">0</span>;    <span class="hljs-comment">//每次计算完都将sum置为零</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> result == INT32_MAX ? <span class="hljs-number">0</span> : result; <span class="hljs-comment">//判断是否向result中有过输入</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>双指针思路：首先定义了两个指针，一个指针指向了起始位置，而另外一个指针指向了终止位置随后通过while循环不地向后进行遍历直到找出对短的子序列长度，而核心就在于，移动起始位置的时候需要先将起始位置所对应的值减去后再将执行起始位置+1的操作。代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 暴力解法</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-type">int</span> target, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> result = INT32_MAX; <span class="hljs-comment">//用于存最后的结果</span><br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>; <span class="hljs-comment">//用于记录所有临时子区间的和, 也就是所有子序列的和</span><br>        <span class="hljs-type">int</span> sublength = <span class="hljs-number">0</span>; <span class="hljs-comment">//用于记录子序列的值</span><br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; <span class="hljs-comment">//起始指针</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; nums.<span class="hljs-built_in">size</span>(); j++)&#123;<br>            sum += nums[j]; <span class="hljs-comment">//将遍历的数组的j个值都相加</span><br>            <span class="hljs-keyword">while</span>(sum &gt;= target)&#123;       <span class="hljs-comment">//采用while 不断地推进循环， eg. [1, 1, 1, 1, 1, 1, 1, 1 ,1 ,1, 15 ] target = 10</span><br>                sublength = j - i + <span class="hljs-number">1</span>; <span class="hljs-comment">//记录此时的子序列长度</span><br>                result = result &lt; sublength ? result : sublength;       <span class="hljs-comment">// 比较result是否为最小的值</span><br>                sum -= nums[i];      <span class="hljs-comment">// 精华  sum 一个一个去减掉i所对应的值</span><br>                i++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result == INT32_MAX ? <span class="hljs-number">0</span> : result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>数组</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>有序数组的平方-leetcode-977</title>
    <link href="/2022/08/18/%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9-leetcode-977/"/>
    <url>/2022/08/18/%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9-leetcode-977/</url>
    
    <content type="html"><![CDATA[<h2 id="有序数组的平方977题链接">有序数组的平方977题<ahref="https://leetcode.cn/problems/squares-of-a-sorted-array/">链接🚀</a></h2><p>双指针思路如下图所示： <img src="/img/md/leetcode/leetcode977.jpg"alt="tupian" /></p><p>代码如下所示（c++）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 输入是一个有序数组，要求输出也是一个有序数组</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sortedSquares</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">result</span><span class="hljs-params">(nums.size() , <span class="hljs-number">0</span>)</span></span>; <span class="hljs-comment">//初始化一个数组大小为nums.size()的值均为0的数组，用于保存新的元素</span><br>        <span class="hljs-type">int</span> k = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;    <span class="hljs-comment">//新数组的索引</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &lt;= j;)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i]*nums[i] &gt; nums[j]*nums[j])&#123;  <span class="hljs-comment">//更新左指针，并将最大值赋值给result数组</span><br>                result[k] = nums[i]*nums[i];<br>                k--;<br>                i++;<br>            &#125;<span class="hljs-keyword">else</span> &#123;     <span class="hljs-comment">//更新右指针 ， 并将最大值赋值给result数组</span><br>                result[k] = nums[j]*nums[j];<br>                k--;<br>                j--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>采用暴力破解法思路如下：将每个元素都平分之后存在当前数组的位置，然后再将得到的新数据进行一个快速排序就得到了相应的结果，此时的时间复杂度为(nlogn)。代码如下： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sortedSquares</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span></span>&#123;<br>        <span class="hljs-comment">//将每个数都平方之后再采用快速排序</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>() ; i++)&#123;<br>            nums[i] *= nums[i];<br>        &#125;<br>        <span class="hljs-comment">// 快排</span><br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>() , nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">return</span> nums;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>数组</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>移除元素-leetcode-27</title>
    <link href="/2022/08/17/%E7%A7%BB%E9%99%A4%E6%95%B0%E7%BB%84-leetcode-27/"/>
    <url>/2022/08/17/%E7%A7%BB%E9%99%A4%E6%95%B0%E7%BB%84-leetcode-27/</url>
    
    <content type="html"><![CDATA[<h2 id="数组-移除元素链接">数组-移除元素<ahref="https://leetcode.cn/problems/remove-element/">链接🚀</a></h2><p>采用双指针法（c++）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 采用双指针法</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">removeElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>        <span class="hljs-comment">// 获取数组长度</span><br>        <span class="hljs-type">int</span> length = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">// 定义一个慢指针用于保存新数组的值</span><br>        <span class="hljs-type">int</span> lower = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> fast = <span class="hljs-number">0</span>; fast &lt; length; fast++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[fast] != val)&#123;   <span class="hljs-comment">// 判断val是否为待删除的值，若不是则将新元素添加到新数组当中 若是则将快指针加+</span><br>                nums[lower] = nums[fast];  <span class="hljs-comment">// 新元素放到新数组中</span><br>                lower++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> lower;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>采用暴力破解法（c++）:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 采用暴力解法</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">removeElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>        <span class="hljs-comment">// 获取数组长度</span><br>        <span class="hljs-type">int</span> length = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">// 定义一个外层循环遍历数组中的所有值判断是否有值与当前的value的值相同，若相同则将后面的值进行替换</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i] == val)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i +<span class="hljs-number">1</span>; j &lt; length; j++)&#123;<br>                    nums[j - <span class="hljs-number">1</span>] = nums[j];<br>                &#125;<br>                i--;<br>                length--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> length;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>数组</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数组的二分查找-leetcode703</title>
    <link href="/2022/08/17/%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-leetcode703/"/>
    <url>/2022/08/17/%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-leetcode703/</url>
    
    <content type="html"><![CDATA[<h2 id="leetcode数组703题链接">LeetCode数组703题<ahref="https://leetcode.cn/problems/binary-search/">链接🚀</a></h2><p>手撕代码如下 <img src="/img/md/leetcode/leetcode703arrays.jpg"alt="aa" /> 左闭右闭情况代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 定义左闭右闭区间 如[left , right]</span><br>        <span class="hljs-type">int</span> right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; <span class="hljs-comment">// -1 因为数据下标从零开始因此取的数据长度后减1</span><br>        <span class="hljs-keyword">while</span>(left &lt;= right)&#123;<br>            <span class="hljs-type">int</span> middle = (left + right) / <span class="hljs-number">2</span>; <span class="hljs-comment">//取得中间值</span><br>            <span class="hljs-keyword">if</span>(nums[middle] &gt; target)&#123;  <br>                right = middle - <span class="hljs-number">1</span>;         <span class="hljs-comment">// 在左区间 所以更新右边界 为 [left , middle - 1]</span><br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[middle] &lt; target)&#123;<br>                left = middle + <span class="hljs-number">1</span>;          <span class="hljs-comment">// 在右区间 所以更新左边界 为 [middle + 1 , right]</span><br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> middle;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <span class="hljs-comment">// 循环没有找到因此输出下标为 -1;</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>左闭右开代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 定义左闭右开区间 如[left , right)</span><br>        <span class="hljs-type">int</span> right = nums.<span class="hljs-built_in">size</span>(); <span class="hljs-comment">// 此时不用减1的操作是因为 虚拟了一个位置 , 类似于是放置了一个假哨兵 该索引在进行数组访问不可能访问得到</span><br>        <span class="hljs-keyword">while</span>(left &lt; right)&#123; <span class="hljs-comment">//这里的情况就是不可能会出现等于的情况 因为right是当前数组中最大的地址</span><br>            <span class="hljs-type">int</span> middle = (left + right) / <span class="hljs-number">2</span>; <span class="hljs-comment">//取得中间值</span><br>            <span class="hljs-keyword">if</span>(nums[middle] &gt; target)&#123;  <br>                right = middle ;         <span class="hljs-comment">// 在左开区间 所以更新右边界 为 [left , middle ] 保证左开区间</span><br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[middle] &lt; target)&#123;<br>                left = middle + <span class="hljs-number">1</span>;          <span class="hljs-comment">// 在右区间 所以更新左边界 为 [middle + 1 , right]</span><br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> middle;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <span class="hljs-comment">// 循环没有找到因此输出下标为 -1;</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>数组</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>一种新的基于注意力的全局和局部信息融合神经网络的群体推荐</title>
    <link href="/2022/07/30/%E4%B8%80%E7%A7%8D%E6%96%B0%E7%9A%84%E5%9F%BA%E4%BA%8E%E6%B3%A8%E6%84%8F%E5%8A%9B%E7%9A%84%E5%85%A8%E5%B1%80%E5%92%8C%E5%B1%80%E9%83%A8%E4%BF%A1%E6%81%AF%E8%9E%8D%E5%90%88%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E7%BE%A4%E4%BD%93%E6%8E%A8%E8%8D%90/"/>
    <url>/2022/07/30/%E4%B8%80%E7%A7%8D%E6%96%B0%E7%9A%84%E5%9F%BA%E4%BA%8E%E6%B3%A8%E6%84%8F%E5%8A%9B%E7%9A%84%E5%85%A8%E5%B1%80%E5%92%8C%E5%B1%80%E9%83%A8%E4%BF%A1%E6%81%AF%E8%9E%8D%E5%90%88%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E7%BE%A4%E4%BD%93%E6%8E%A8%E8%8D%90/</url>
    
    <content type="html"><![CDATA[<h3 id="摘要">摘要</h3><p>组活动在社交媒体上非常得活跃，组推荐得目的是为了能够给目标组推荐一个感兴趣的列表。现有的深度学习方法关注于单一的用户与组交互。这会导致非常大的数据稀疏性。应该还有别的交互方式来丰富组表示，比如说组与项目的交互。这种发生在群体范围内的互动，形成了对某一群体的局部看法。群体表征可以根据群体之间的相似性进行，从而形成对某一群体的全局看法。在文章中提出来的基于注意力机制的方法激活且丰富了用户与群组，群组与项目之间的交互，并且形成了群体的局部表示。然后再利用ANN获得组与组之间的相似度，进而获得全局表示。然后attention机制会将群内本地特征与各个群组特征进行融合，进而形成群组的综合特征。最后再神经协同过滤的框架（NCF）下进行训练。</p><h3 id="介绍">介绍</h3><!-- 介绍了组推荐的发展历程，经历哪些阶段，采用了哪些思想 -->传统的群组推荐系统是利用用户显式的个人信息来生成群组的信息。但是这种方法并未考虑到群组内成员的偏好的不同。然后就有一些工作来对群组决策进行建模，通过考虑组内用户偏好与显式特征建模。最近出现了一些采用深度学习的方法对固有信息进行建模。由于组-项目的交互数据的稀疏性，组-项目的表示变得很重要，因为有一些研究人员对组内成员偏好建模，然后采用动态权重信息获取组偏好。这些方法在有丰富的交互数据以及稳定的成员前提下表现得很好，但是在数据极度稀疏得情况下并没有很好得效果。为了增强组特征，研究人员利用项目-用户交互与用户-组交互来表征一个组内得所有成员。通过聚合成员间得特征来传递item的特征，用最后得到的item特征来作为组特征。<hr/><!-- 现有的工作有哪些挑战 --><p>基于深度学习的模型在做组推荐的时候仍然面临着三个问题：</p><ol type="1"><li>有着许多丰富的交互数据，但是并没有将其利用起来。其交互数据有三种分别是：用户-项目交互、用户-组交互、组-项目交互。<ul><li>没有将其交互数据彻底利用起来</li><li>这种将间接的交互数据聚合起来时，会造成特征损失，当在特征传播时。如图所示： <img src="/img/md/grouprec/interaction.jpg"alt="didi" /></li><li>因此我们思考要如何充分的利用这些交互信息。</li></ul></li><li>考虑在深度学习框架下如何充分利用组与组之间的相似性来增强组表征，将组当作是一个虚拟用户。</li><li>不同的特征对于组表征是不一样的。假如有一个长期稳定的话题，则在特征选取的时候就会选择一个与主题相近的特征，当是由朋友组成的群组中，则更会偏重于组内成员偏好。但是现有的级联操作和均值运算并不能很好的模拟这种影响。不同类型之间的特征存在着相互影响。并且将其平等看待。挑战在于根据不同种类特征的影响来对不同的交互数据进行融合以达到组推荐的目的。<!-- 基于上述的动机，于是作者自己提出的框架，该框架有哪些部分组成，每个部分分别是干什么的 -->作者在文中提出了GLIF，通过融合全局的组与组内的特征信息来表示组特征。主要是分为两个方面，其一是，在捕获全局信息时，通过捕获组与组之间的共享信息来表示组特征。简言之就是，组偏好之间共性如何捕捉。其二是，在捕获组内特征时，是通过对组内交互数据建模，比如对组-Item、组-user交互数据建模。这种方法简言之，就是组内决策如何做。要不要考虑组内之间的影响。具体如下：</li></ol><ul><li>利用ANN捕捉三种不同的交互数据以达到最大化利用，以达到组内特征表示</li><li>利用捕捉组与组之间的共同偏好，以达到全局的全局组表示</li><li>由于相似组对目标组影响力的不同，采用ANN来聚合相似组。</li><li>最后再采用ANN对全局和本地来进行深度融合该方法在三个真实数据集上得到了实现<hr/><!-- 陈述了自己所做的贡献以及本文的每一节的脉络 -->该文章的贡献：</li></ul><ol type="1"><li>挖掘全局信息的工作</li><li>交互数据全都被整合到了一起学习，通过不同视角来学习item与group的嵌入，再用ANN来学习各个视角下的动态权重。</li><li>提出利用attention机制来聚合组内特征和组间特征的框架。</li><li>在HR(点击率)和NDCG(归一化后折损累计)达到了比较好的效果。<!-- 自己的工作属于现有工作的哪个类别。将不同类别工作的发展一一交代或者罗列出来 --></li></ol><h3 id="相关工作">相关工作</h3><p>现有的工作一般有两条路，分别是基于内存的方法和基于模型的方法</p><ol type="1"><li>基于内存的方法</li></ol><ul><li>这种方式是采用显式聚合用户偏好和用户分数。<ul><li>由此就有了评分函数。它将单个模型生成的用户评分聚集起来形成组评分。而这些聚合方法有采用平均聚合、最少痛苦聚合以及最大满意度聚合。这些方式研究表明，并不都是最好的。基于早先的工作，那么就提出在聚合用户评分时把用户的影响力考虑进去。例如，GroupSA提出了一个社会关注网络，该网络考虑了社会影响和动态权重调整，对一个群体的投票方案进行建模，然后为成员分配权重，得到群体推荐的最终得分。</li><li>组偏好，将显式用户偏好聚合形成虚拟组偏好。将这个组就虚拟为了一个用户，利用个性化推荐的方式来生成groupitem。有研究人员做groupagent来表示的。目的是为了聚合用户偏好。还有一种是利用相对节点重要性来捕捉节点中哪些节点的关系更接近来表示总的组表示。</li></ul></li></ul><ol start="2" type="1"><li>基于模型的方法-利用交互关系来做组推荐</li></ol><ul><li>组决策往往是由最有影响力那个来做决定的。于是研究人员就提出了一个共识模型，该模型考虑通过用户的影响力与组行为来模拟群体活动的决策过程。就是通过用户影响力来对组决策进行建模。</li><li>随着注意力机制的广泛应用，基于注意力机制的组决策模型中，用户的影响是由特定的组或项动态决定的。研究人员首先用ANN动态的学习组内成员的相对重要性，考虑组-用户交互数据，用组成员偏好来表示组偏好。用次注意神经网络对组中的用户-用户交互进行建模，然后利用剩余的成员来代表用户的偏好。还有的研究人员从多个视角采用注意力机制融合用户、项目、组的多个特征。第一步，先利用user-item交互分别得到用户表征和物品表征，第二步，利用group-user交互来获取group表征，最后在NCF框架下采用注意力机制聚合用户表征以或者组表征并且优化它。还有的研究人员利用朋友偏好在社交网络中构建超边以获得组间相似性并用于推荐。</li></ul><!-- 讲述自己的方法与上述方法有哪些不同点 --><ol type="1"><li>充分利用了三种类型的交互关系</li><li>提出了局部与全局注意力的概念</li><li>**</li></ol><h3 id="问题定义">问题定义</h3><p>介绍两种类型的ANN，分别是 type-based ANN and k types-based ANN。</p><h4 id="符号与定义">符号与定义</h4><p>该论文中<span class="math inline">\(\mathbf{X}\)</span>大写且加黑代表矩阵，<spanclass="math inline">\(X\)</span>大写不加黑代表集合 ，<spanclass="math inline">\(\mathbf{x}\)</span> 小写加黑代表向量 <spanclass="math inline">\(x\)</span> 小写不加黑代表常量。<br> <spanclass="math inline">\(U = \left\{u_{1}, u_{2}, \cdots,u_{n}\right\}\)</span>, $ V={v_{1}, v_{2}, , v_{m}} $, $ G={g_{1},g_{2}, , g_{s}} $分别代表用户集合、项目集合、组集合。<br> 目标组 <spanclass="math inline">\(g_{l}\)</span>,其中组用户是 <spanclass="math inline">\(U\)</span>里面的用户组成。有三种不同的交互，分别是项目-用户交互、用户-组交互、组-项目交互。<br>其中项目-用户交互成立是：一个项目被用户选择或者是评分称为一个交互。用户-项目指的是用户属于一个组中。项目-组交互是指该组对项目有操作的历史纪录。<br>在文中 <span class="math inline">\(\boldsymbol{A}=\left[a_{li}\right]_{s \times m}\)</span> 代表着组-项目交互矩阵, <spanclass="math inline">\(\boldsymbol{B}=\left[b_{i j}\right]_{m \timesn}\)</span> 代表着用户-项目交互矩阵。<br> <spanclass="math inline">\(\boldsymbol{C} =\left[c_{l j}\right]_{s \timesn}\)</span>代表组-用户交互矩阵。而组推荐问题被定义为为组中用户推荐一系列项目清单。于是就可以用公式形式化的定义为：<span class="math display">\[   \text { Input: } U, V, G, \boldsymbol{A}, \boldsymbol{B},\boldsymbol{C}\]</span> <span class="math display">\[   \text { Output: } f: V \rightarrow \mathbf{R}\]</span></p><h4 id="定义">定义</h4><ol type="1"><li>Definition1 : Inhert Emdedding</li></ol><ul><li>固有嵌入是自带的而且是可学习的参数，它能够反应潜在的用户或组的兴趣。嵌入的初始化采用的是Xavierstrategy策略。</li></ul><ol start="2" type="1"><li>Definition2 : <span class="math inline">\(\left.(\gamma \text{-neighbor set })\left(N_{g_{l}}^{\gamma}\right)\right)\)</span></li></ol><ul><li>代表与目标组相似的top个组。第一步，计算目标组与其他组的相似性。第二步，对其余组相似性评分排序。最后根据排序序列得到与目标组相近的邻居组集合被标记为$N_{g_{l}}^{} $, $ $是一个超参数，控制着目标组的邻居节点数量。</li></ul><ol start="3" type="1"><li>Definition3 global information:</li></ol><ul><li>高度相似的群体具有相同的品味。相似度高的群体具有全局信息。由此全局信息被形式化定义为：<span class="math display">\[\left\{g_{l, k} \mid g_{l, k} \in\right.\left.N_{g_{l}}^{\gamma} ; g_{l,k} \in G\right\}\]</span></li></ul><ol start="4" type="1"><li>Definition4 local infomation:</li></ol><ul><li>表示的是组内成员的交互信息。组内的每个用户与组的交互和每个项目与组的交互被称为本地信息。<br></li></ul><p>组内用户-组交互： <span class="math display">\[u_{j} \in I_{u}\left(g_{l}\right)\]</span> 组内项目-组交互： <span class="math display">\[v_{i} \in I_{v}\left(g_{l}\right)\]</span></p><h4 id="attention模块">attention模块</h4><h3 id="方法">方法</h3><h3 id="实验">实验</h3>]]></content>
    
    
    <categories>
      
      <category>GroupRec</category>
      
      <category>group fusion</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Group Recommendation attention mechanism</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NBFNet:一种通用的神经网络链接预测框架</title>
    <link href="/2022/07/30/NBFNet-%E4%B8%80%E7%A7%8D%E9%80%9A%E7%94%A8%E7%9A%84%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E9%93%BE%E6%8E%A5%E9%A2%84%E6%B5%8B%E6%A1%86%E6%9E%B6/"/>
    <url>/2022/07/30/NBFNet-%E4%B8%80%E7%A7%8D%E9%80%9A%E7%94%A8%E7%9A%84%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E9%93%BE%E6%8E%A5%E9%A2%84%E6%B5%8B%E6%A1%86%E6%9E%B6/</url>
    
    <content type="html"><![CDATA[<h3 id="摘要">摘要</h3><p>基于路径的链路预测：具体地说，我们将结点对的表示定义为结点之间所有路径表示的广义和，每个路径表示为路径中的边表示的广义积。提出的动机来自于，最短路径求解问题。由此提出了路径公式，以此解决广义的最短路径求解问题。为了进一步解决路径制定的能力，提出了NBFNet。NBFNet用了三个神经网络组件对广义的 Bellman-Ford算法参数化，分别是：指示器函数、消息函数、聚合函数，分别对应了边界条件的，乘法操作和求和操作。NBFNet集合多种传统的方法，并且在同构图和关系图（知识图谱）上有很不错的效果。</p><h3 id="介绍">介绍</h3><!-- 先介绍传统的基于路径的表示学习：主要有哪些方法，方法怎么做的。他们的共同缺点是啥 不好说的话就直接说：那些都很好，但是并不是最好的最优的解法。 --><p>现有的衡量节点之间关系的方法通常有以下几种，比如：</p><ul><li>Katz index，该方法通过定义节点对间路径的加权数衡量。<br></li><li>PageRank算法是通过一个节点到另一个节点的随机游走概率来衡量两个节点的相似度。</li><li>Graphdistance算法则是通过计算两个节点间的最短路径来衡量节点间的联系。</li></ul>这些方法都有良好的解释性和归纳性并且可以用于大规模图。这些是基于手工的度量而设计的，但是对于现实数据中的链接并不是最优的解法。<hr/><!-- 再介绍现有GNN方法灾图中链接任务中，现存了哪些工作，这些工作的共同点是什么，共同缺点是什么。 -->得益于GNN方法的强大表达力，他们能够抽取节点的邻居节点的重要特征做来链接预测，并取得了很好的成绩。但是自动提取图中的重要节点，它的限制是只能预测训练图上的新的链接。缺乏可解释性。虽然有一些GNN方法是通过提取子图中的特征，以此在新图中做链接预测，但是它的扩展性受到影响。<hr/><!-- 据此提出了自己的方法，然后说明具体是怎么做的，那个方法是怎么写的。然后再比较自己的方法与现有的方法有哪些优越性（支持哪些任务，时间复杂度等）， 将这些优化用表格化的形式表示出来。--><p>NBFNet试图找出一种既具有传统的基于路径的方法的优点又具有基于图神经网络的最新方法的优点的方法。具体地说，我们将结点对的表示定义为它们之间所有路径表示的广义和，其中每个路径表示定义为路径中的边表示的广义积。a pair of nodes representation &lt;- node path representation sum &lt;-edge representation product 。传统的图游走算法、图论算法都是上述公式的特例。</p><p>Bellman-Ford算法中的求和操作与乘积操作缺乏灵活性，提出了基于GNN的Bellman-Ford算法改进版NBFNet。在对Bellman-Ford算法参数化过程中的三个函数分别是indicator函数的作用是为每个节点初始化一个表示，并作为边界条件。meassge函数与aggregate函数分别表示乘积操作与求和操作。NBFNet在做链接预测任务时不仅支持同构图，同时也支持多种关系图（知识图谱）<!-- 摆事实，说结果，实验结果相比与其他的取得了哪些优越性，实验数据提升了多少。 --></p><h3 id="相关工作">相关工作</h3>现有的链接预测主要有三种办法，分别是：基于路径的方法、嵌入方法与图神经网络方法。<hr/><ol type="1"><li>基于路径的方法<!-- 先介绍在同构图中有哪些表现，再介绍在知识图谱中有哪些表现，最后介绍他们有哪些缺点或不足，然后谁又解决了这些缺点。 --><ul><li>通过计算节点间相似度来做链路预测</li></ul></li><li>嵌入方法<ul><li>通过保留图结构来学习每个节点和边的分布表示。比如基于游走的，DeepWalk、Line在同构图上。又如在知识图谱上有TransE、 DistMult、RotatE。其次就是基于这些的改进方法的共同点。缺点是：不能够明确地编码子图而且并不能用于Inductive设置。</li></ul></li><li>图神经网络方法<!-- 介绍现有的GNN方法，然后与自己的方法对比，方法或者思想相似却有不同的地方在哪里，其他的方法有可以借鉴到本论文中的哪些地方。 --><ul><li>该方法具有首先对图的拓扑结构进行编码的模型。对于链接预测任务，比较流行的框架是采用自动编码器，将节点进行编码，然后利用边作为节点对上的函数进行解码。如果数据集提供节点特征，这种框架可能是归纳的，但只有当节点特征不可用时，这种框架才具有transductive。其他的GNN框架SEAL等可以显式对子图编码，而且被证明这种方法比自动编码效果要好，与此同时可以解决induction设置。相比之下，NBFNet显式地捕捉了两个节点之间的路径来进行链路预测，同时实现了相对较低的时间复杂度。</li></ul></li></ol><h3 id="方法论">方法论</h3><h3 id="实验">实验</h3><h3 id="总结">总结</h3>]]></content>
    
    
    <categories>
      
      <category>LinkPrediction</category>
      
      <category>NBFNet</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基于路径的链路预测，同构图，知识图谱</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HeteGraph学习笔记</title>
    <link href="/2022/07/27/HeteGraph%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/07/27/HeteGraph%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 边的类型</span><br>edges = &#123;<br>        <span class="hljs-string">&#x27;click&#x27;</span>: [(<span class="hljs-number">0</span>, <span class="hljs-number">4</span>), (<span class="hljs-number">0</span>, <span class="hljs-number">7</span>), (<span class="hljs-number">1</span>, <span class="hljs-number">6</span>), (<span class="hljs-number">2</span>, <span class="hljs-number">5</span>), (<span class="hljs-number">3</span>, <span class="hljs-number">6</span>)],<br>        <span class="hljs-string">&#x27;buy&#x27;</span>: [(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>), (<span class="hljs-number">1</span>, <span class="hljs-number">4</span>), (<span class="hljs-number">1</span>, <span class="hljs-number">6</span>), (<span class="hljs-number">2</span>, <span class="hljs-number">7</span>), (<span class="hljs-number">3</span>, <span class="hljs-number">5</span>)],<br>    &#125;<br><br>clicked= [(j, i) <span class="hljs-keyword">for</span> i, j <span class="hljs-keyword">in</span> edges[<span class="hljs-string">&#x27;click&#x27;</span>]]<br>bought = [(j, i) <span class="hljs-keyword">for</span> i, j <span class="hljs-keyword">in</span> edges[<span class="hljs-string">&#x27;buy&#x27;</span>]]<br>edges[<span class="hljs-string">&#x27;clicked&#x27;</span>]= clicked<br>edges[<span class="hljs-string">&#x27;bought&#x27;</span>]= bought<br><span class="hljs-comment"># 节点类型</span><br>node_types = [(<span class="hljs-number">0</span>, <span class="hljs-string">&#x27;user&#x27;</span>), (<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;user&#x27;</span>), (<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;user&#x27;</span>), (<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;user&#x27;</span>), (<span class="hljs-number">4</span>, <span class="hljs-string">&#x27;item&#x27;</span>),<br>             (<span class="hljs-number">5</span>, <span class="hljs-string">&#x27;item&#x27;</span>),(<span class="hljs-number">6</span>, <span class="hljs-string">&#x27;item&#x27;</span>), (<span class="hljs-number">7</span>, <span class="hljs-string">&#x27;item&#x27;</span>)]<br><br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-keyword">import</span> paddle<br><span class="hljs-keyword">import</span> paddle.nn <span class="hljs-keyword">as</span> nn<br><span class="hljs-keyword">import</span> pgl<br>seed = <span class="hljs-number">0</span><br>np.random.seed(<span class="hljs-number">0</span>)<br>paddle.seed(<span class="hljs-number">0</span>)<br><br>num_node = <span class="hljs-built_in">len</span>(node_types)<br><br>node_feature = &#123;<br>    <span class="hljs-string">&#x27;feature&#x27;</span> :   np.random.randn(num_node, <span class="hljs-number">8</span>).astype(<span class="hljs-string">&quot;float32&quot;</span>)<br>&#125;<br><br>labels = np.array([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>])<br><br>g = pgl.HeterGraph(edges,<br>                   node_types=node_types,<br>                   node_feat=node_feature)<br></code></pre></td></tr></table></figure><h2 id="messagepassing-on-hetegraph">MessagePassing on HeteGraph</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HeteMessagePassingLayer</span>(nn.Layer):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, in_dim, out_dim, etype</span>) -&gt; <span class="hljs-literal">None</span>:<br>        <span class="hljs-built_in">super</span>(HeteMessagePassingLayer, self).__init__()<br>        self.in_dim= in_dim<br>        self.out_dim= out_dim<br>        self.etype= etype<br><br>        self.weight= []<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(self.etype)):<br>            self.weight.append(self.create_parameter(shape=[self.in_dim, self.out_dim]))<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, graph, feat</span>):<br>        <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">            src_feat: 源特征</span><br><span class="hljs-string">            dst_feat: 目标特征</span><br><span class="hljs-string">            edge_feat: 边类型</span><br><span class="hljs-string">        &#x27;&#x27;&#x27;</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">send_func</span>(<span class="hljs-params">src_feat, dst_feat, edge_feat</span>):<br>            <span class="hljs-keyword">return</span> src_feat<br>        <br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">recv_func</span>(<span class="hljs-params">msg</span>):<br>            <span class="hljs-keyword">return</span> msg.reduce_mean(msg[<span class="hljs-string">&quot;h&quot;</span>])<br><br>        feat_list= []<br>        <span class="hljs-keyword">for</span> idx,etype <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(self.etype):<br>            h= paddle.matmul(feat, self.weight[idx])            <span class="hljs-comment"># 将输入的特征 * 初始化权重 = h 特征信息</span><br>            msg= graph[etype].send(send_func, src_feat=&#123;<span class="hljs-string">&quot;h&quot;</span>:h&#125;) <span class="hljs-comment"># 根据边类型信息通过send函数发送将h作为信息发送</span><br>            h= graph[etype].recv(recv_func, msg)                <span class="hljs-comment"># 根据边类型信息通过recv函数接收源信息</span><br>            feat_list.append(h)                                 <span class="hljs-comment"># 将信息获取之后添加到信息列表中去</span><br>        <br>        h= paddle.stack(feat_list, axis= <span class="hljs-number">0</span>)<br>        h= paddle.<span class="hljs-built_in">sum</span>(h, axis=<span class="hljs-number">0</span>)<br><br>        <span class="hljs-keyword">return</span> h<br><br>        <br></code></pre></td></tr></table></figure><h2id="通过两个堆叠的信息传递网络创建一个简单的gnn">通过两个堆叠的信息传递网络创建一个简单的GNN</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">HeteGNN</span>(nn.Layer):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, in_dim, hiddensize, etype, num_class</span>):<br>        <span class="hljs-built_in">super</span>(HeteGNN, self).__init__()<br>        self.in_dim= in_dim<br>        self.hiddensize= hiddensize<br>        self.etype= etype<br>        self.num_class= num_class<br><br>        self.layers= nn.LayerList()                                                             <span class="hljs-comment"># 这是一个可以堆叠几个网络层的函数</span><br>        self.layers.append(HeteMessagePassingLayer(self.in_dim, self.hiddensize, self.etype))   <span class="hljs-comment"># 第一个信息传递层</span><br>        self.layers.append(HeteMessagePassingLayer(self.hiddensize, self.hiddensize, self.etype))   <span class="hljs-comment"># 第二个信息传递层</span><br><br>        self.linear= nn.Linear(self.hiddensize, self.num_class)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, graph, feat</span>):<br>        h= feat<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(self.layers)):<br>            h= self.layers[i](graph, h)<br>        <br>        logits= self.linear(h)<br><br>        <span class="hljs-keyword">return</span> logits<br><br></code></pre></td></tr></table></figure><h2 id="training">training</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 初始化模型</span><br><br><br>model= HeteGNN(<span class="hljs-number">8</span>, <span class="hljs-number">8</span>, g.edge_types, <span class="hljs-number">2</span>)<br><span class="hljs-comment"># 初始化正则化项</span><br>criterion= paddle.nn.loss.CrossEntropyLoss()<br><span class="hljs-comment"># define optimizer</span><br>optim= paddle.optimizer.Adam(learning_rate=<span class="hljs-number">0.05</span>,<br>                             parameters= model.parameters())<br><br>g.tensor()<br>labels= paddle.to_tensor(labels)<br><br><span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>):<br>    logits= model(g, g.node_feat[<span class="hljs-string">&quot;feature&quot;</span>])<span class="hljs-comment"># 将图数据与图节点特征作为参数装入</span><br>    loss= criterion(logits, labels)         <span class="hljs-comment"># 计算标签与预测值之间的损失</span><br>    loss.backward()                         <span class="hljs-comment"># 反向传播</span><br>    optim.step()<br>    optim.clear_grad()<br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;epoch : %s | loss : %.4f&quot;</span> % (epoch, loss.numpy()[<span class="hljs-number">0</span>]))<br></code></pre></td></tr></table></figure><pre><code class="hljs">epoch : 0 | loss : 1.5617epoch : 1 | loss : 1.3445epoch : 2 | loss : 1.1334epoch : 3 | loss : 0.9315epoch : 4 | loss : 0.7439epoch : 5 | loss : 0.5805epoch : 6 | loss : 0.4606epoch : 7 | loss : 0.4075epoch : 8 | loss : 0.4110epoch : 9 | loss : 0.4277epoch : 10 | loss : 0.4279epoch : 11 | loss : 0.4050epoch : 12 | loss : 0.3645epoch : 13 | loss : 0.3161epoch : 14 | loss : 0.2677epoch : 15 | loss : 0.2244epoch : 16 | loss : 0.1887epoch : 17 | loss : 0.1613epoch : 18 | loss : 0.1421epoch : 19 | loss : 0.1301epoch : 20 | loss : 0.1233epoch : 21 | loss : 0.1193epoch : 22 | loss : 0.1163epoch : 23 | loss : 0.1127epoch : 24 | loss : 0.1077epoch : 25 | loss : 0.1014epoch : 26 | loss : 0.0941epoch : 27 | loss : 0.0865epoch : 28 | loss : 0.0789epoch : 29 | loss : 0.0720epoch : 30 | loss : 0.0658epoch : 31 | loss : 0.0606epoch : 32 | loss : 0.0561epoch : 33 | loss : 0.0524epoch : 34 | loss : 0.0494epoch : 35 | loss : 0.0468epoch : 36 | loss : 0.0446epoch : 37 | loss : 0.0428epoch : 38 | loss : 0.0411epoch : 39 | loss : 0.0396epoch : 40 | loss : 0.0383epoch : 41 | loss : 0.0371epoch : 42 | loss : 0.0359epoch : 43 | loss : 0.0349epoch : 44 | loss : 0.0339epoch : 45 | loss : 0.0330epoch : 46 | loss : 0.0320epoch : 47 | loss : 0.0311epoch : 48 | loss : 0.0303epoch : 49 | loss : 0.0294epoch : 50 | loss : 0.0286epoch : 51 | loss : 0.0278epoch : 52 | loss : 0.0270epoch : 53 | loss : 0.0263epoch : 54 | loss : 0.0256epoch : 55 | loss : 0.0249epoch : 56 | loss : 0.0243epoch : 57 | loss : 0.0238epoch : 58 | loss : 0.0232epoch : 59 | loss : 0.0227epoch : 60 | loss : 0.0223epoch : 61 | loss : 0.0219epoch : 62 | loss : 0.0215epoch : 63 | loss : 0.0211epoch : 64 | loss : 0.0208epoch : 65 | loss : 0.0204epoch : 66 | loss : 0.0201epoch : 67 | loss : 0.0198epoch : 68 | loss : 0.0195epoch : 69 | loss : 0.0192epoch : 70 | loss : 0.0189epoch : 71 | loss : 0.0186epoch : 72 | loss : 0.0184epoch : 73 | loss : 0.0181epoch : 74 | loss : 0.0179epoch : 75 | loss : 0.0176epoch : 76 | loss : 0.0174epoch : 77 | loss : 0.0172epoch : 78 | loss : 0.0170epoch : 79 | loss : 0.0167epoch : 80 | loss : 0.0165epoch : 81 | loss : 0.0163epoch : 82 | loss : 0.0161epoch : 83 | loss : 0.0159epoch : 84 | loss : 0.0157epoch : 85 | loss : 0.0155epoch : 86 | loss : 0.0153epoch : 87 | loss : 0.0151epoch : 88 | loss : 0.0150epoch : 89 | loss : 0.0148epoch : 90 | loss : 0.0146epoch : 91 | loss : 0.0144epoch : 92 | loss : 0.0143epoch : 93 | loss : 0.0141epoch : 94 | loss : 0.0140epoch : 95 | loss : 0.0138epoch : 96 | loss : 0.0137epoch : 97 | loss : 0.0135epoch : 98 | loss : 0.0134epoch : 99 | loss : 0.0132</code></pre>]]></content>
    
    
    <categories>
      
      <category>PaddlePgl</category>
      
      <category>Hetegraph</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pgl</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PGL学习笔记</title>
    <link href="/2022/07/24/PGL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/07/24/PGL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2id="关于forward函数没有对齐所造成的结果">关于forward()函数没有对齐所造成的结果</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python">    Output exceeds the size limit. Open the full output data <span class="hljs-keyword">in</span> a text editor<br>---------------------------------------------------------------------------<br>NotImplementedError                       Traceback (most recent call last)<br>/tmp/ipykernel_2551562/<span class="hljs-number">3523250689.</span>py <span class="hljs-keyword">in</span> &lt;module&gt;<br>    <span class="hljs-number">1</span> gcn.train()<br>    <span class="hljs-number">2</span> <span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">30</span>):<br>----&gt; <span class="hljs-number">3</span>     logits = gcn(g, g.node_feat[<span class="hljs-string">&#x27;nfeat&#x27;</span>])<br>    <span class="hljs-number">4</span>     loss= criter(logits, y)<br>    <span class="hljs-number">5</span>     loss.backward()<br><br>/home/L/anconda3/envs/pgl/lib/python3<span class="hljs-number">.7</span>/site-packages/paddle/fluid/dygraph/layers.py <span class="hljs-keyword">in</span> __call__(self, *inputs, **kwargs)<br>    <span class="hljs-number">928</span>             <span class="hljs-keyword">return</span> self.forward(*inputs, **kwargs)<br>    <span class="hljs-number">929</span>         <span class="hljs-keyword">else</span>:<br>--&gt; <span class="hljs-number">930</span>             <span class="hljs-keyword">return</span> self._dygraph_call_func(*inputs, **kwargs)<br>    <span class="hljs-number">931</span> <br>    <span class="hljs-number">932</span>     <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, *inputs, **kwargs</span>):<br><br>/home/L/anconda3/envs/pgl/lib/python3<span class="hljs-number">.7</span>/site-packages/paddle/fluid/dygraph/layers.py <span class="hljs-keyword">in</span> _dygraph_call_func(self, *inputs, **kwargs)<br>    <span class="hljs-number">913</span>                 outputs = self.forward(*inputs, **kwargs)<br>    <span class="hljs-number">914</span>         <span class="hljs-keyword">else</span>:<br>--&gt; <span class="hljs-number">915</span>             outputs = self.forward(*inputs, **kwargs)<br>    <span class="hljs-number">916</span> <br>    <span class="hljs-number">917</span>         <span class="hljs-keyword">for</span> forward_post_hook <span class="hljs-keyword">in</span> self._forward_post_hooks.values():<br><br>/home/L/anconda3/envs/pgl/lib/python3<span class="hljs-number">.7</span>/site-packages/paddle/fluid/dygraph/layers.py <span class="hljs-keyword">in</span> forward(self, *inputs, **kwargs)<br>    <span class="hljs-number">939</span>             **kwargs(<span class="hljs-built_in">dict</span>): unpacked <span class="hljs-built_in">dict</span> arguments<br>...<br>--&gt; <span class="hljs-number">941</span>         <span class="hljs-keyword">raise</span> NotImplementedError<br>    <span class="hljs-number">942</span> <br>    <span class="hljs-number">943</span>     <span class="hljs-keyword">def</span> <span class="hljs-title function_">backward</span>(<span class="hljs-params">self, *inputs</span>):<br><br>NotImplementedError: <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>PaddlePgl</category>
      
      <category>build Graph</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pgl</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux 常用命令</title>
    <link href="/2022/07/23/linux-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <url>/2022/07/23/linux-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h2 id="linux-常用命令">linux 常用命令</h2><ul><li><p>递归删除文件</p><p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">rm</span> -rf 文件目录<br></code></pre></td></tr></table></figure></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Tools</category>
      
      <category>linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Conda的使用</title>
    <link href="/2022/07/23/cuda%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/07/23/cuda%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="conda-使用">conda 使用</h2><ul><li><p>安装与删除环境</p><p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 创建环境</span><br>conda create -n example python=version <span class="hljs-comment"># python=3.7</span><br><span class="hljs-comment"># 移除环境</span><br>conda remove -n octopus --all<br></code></pre></td></tr></table></figure></p></li><li><p>conda安装包</p><p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">conda install -q -y 包名 -c 包名<br></code></pre></td></tr></table></figure></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Tools</category>
      
      <category>conda</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CentOS8更新阿里源</title>
    <link href="/2022/07/21/CentOS8%E6%9B%B4%E6%96%B0%E9%98%BF%E9%87%8C%E6%BA%90/"/>
    <url>/2022/07/21/CentOS8%E6%9B%B4%E6%96%B0%E9%98%BF%E9%87%8C%E6%BA%90/</url>
    
    <content type="html"><![CDATA[<p>1.将源文件备份</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /etc/yum.repos.d/ &amp;&amp; <span class="hljs-built_in">mkdir</span> backup &amp;&amp; <span class="hljs-built_in">mv</span> *repo backup/ <br></code></pre></td></tr></table></figure><p>2.下载阿里源文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-8.repo<br></code></pre></td></tr></table></figure><p>3.更新源文件里的地址</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sed -i -e <span class="hljs-string">&quot;s|mirrors.cloud.aliyuncs.com|mirrors.aliyun.com|g &quot;</span> /etc/yum.repos.d/CentOS-*<br>sed -i -e <span class="hljs-string">&quot;s|releasever|releasever-stream|g&quot;</span> /etc/yum.repos.d/CentOS-*<br></code></pre></td></tr></table></figure><p>4.生成缓存</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum clean all &amp;&amp; yum makecache<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Linux、centos</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
